<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Notentraining</title>
  <!-- Tone.js laden -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.37/Tone.js"></script>
  <!-- VexFlow laden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #ffffff;
      font-family: sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    /* Container f√ºr Einhand-Notation (800px x 200px) */
    #notation {
      display: none; /* wird nur im Einhand-Modus genutzt */
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      max-width: 800px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 1;
    }
    /* Container f√ºr beidh√§ndige Notensysteme:
       Feste H√∂he: 200px + 5px Abstand + 200px = 405px.
       Container wird zentriert und die Systeme werden linksb√ºndig angeordnet. */
    #notationContainer {
      display: none; /* wird nur im "both"-Modus genutzt */
      position: fixed;
      width: 100%;
      max-width: 800px;
      height: 405px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
    }
    /* Die beiden Notationsbereiche im Container */
    #notationTreble, #notationBass {
      width: 100%;
      max-width: 800px;
      margin: 0;
    }
    /* Abstand zwischen den beiden Systemen: 5px unter dem oberen System */
    #notationTreble { margin-bottom: 5px; }
    
    /* SVG-Optimierung f√ºr scharfe Darstellung */
    #notation svg, #notationTreble svg, #notationBass svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
    }
    #notation svg *,
    #notationTreble svg *,
    #notationBass svg * {
      vector-effect: non-scaling-stroke;
    }
    /* Im Dark Mode: Alle SVG-Elemente (au√üer farbiger Markierung) wei√ü */
    body.dark-mode #notation svg *,
    body.dark-mode #notationTreble svg *,
    body.dark-mode #notationBass svg * {
      stroke: #ffffff !important;
      fill: #ffffff !important;
    }
    
    /* Motivationsfenster ‚Äì etwas h√∂her positioniert */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000000;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.7);
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    
    /* Hauptinhalt (UI) */
    #mainContent {
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 1s ease-in;
      padding-bottom: 50px;
    }
    h1 { margin: 20px 0; }
    
    /* Einstellungen-Men√º */
    #settingsPanel {
      position: fixed;
      left: 30px;
      top: 50%;
      transform: translateY(-50%);
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 5px;
      box-sizing: border-box;
      display: inline-block;
      z-index: 10;
      transition: background 0.3s, border-color 0.3s, color 0.3s;
    }
    body.dark-mode #settingsPanel {
      background: #000000;
      border-color: #ffffff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 4px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    .active-mode, .active-level { opacity: 1; }
    .inactive-mode, .inactive-level { opacity: 0.5; }
    body.dark-mode #settingsPanel span { color: #ffffff; }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    
    /* Score & Time */
    #topRightInfo {
      position: fixed;
      top: 10px;
      right: 10px;
      text-align: right;
      font-size: 1.2em;
      color: #000;
      z-index: 10;
    }
    body.dark-mode #topRightInfo { color: #e0e0e0; }
    
    /* Lage-Button ‚Äì wird nur im Einhand-Modus angezeigt */
    #clefTitle {
      display: block;
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      z-index: 10;
      transition: all 0.5s ease, opacity 0.2s;
    }
    body.dark-mode #clefTitle {
      background: #000000;
      border-color: #ffffff;
      color: #ffffff;
    }
    
    /* Notenname-Anzeige */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 1.5em;
      color: #000;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #ffffff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: background-color 0.3s;
    }
    body.dark-mode #welcomeOverlay { background-color: #121212; }
    #welcomeMessage {
      font-size: 2.5em;
      color: #000;
      margin-bottom: 20px;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
  </style>
  
  <script>
    // Globale Variablen
    var currentSeriesSingle = []; // F√ºr Einhand-Modus
    var currentSeriesTreble = []; // F√ºr beidh√§ndig ‚Äì Treble
    var currentSeriesBass = [];   // F√ºr beidh√§ndig ‚Äì Bass
    var seriesCounter = 0;
    var seriesLength = 5; // Anzahl Noten pro System
    var totalAttempts = 0;
    var correctAnswers = 0;
    var level = 3; // Standard-Level
    // Standardmodus: linke Hand in der C Lage
    var selectedMode = "left";
    var rangeArray = ["C", "D", "F", "G", "MC"];
    var currentRangeIndex = 0;
    var currentRange = rangeArray[currentRangeIndex];
    var soundEnabled = true;
    var firstNotePlayed = false;
    // F√ºr Motivationsnachrichten
    var correctNoteCount = 0;
    var nextMotivationThreshold = getRandomThreshold();
    // Bei "both": Aktuelle Phase ("treble" oder "bass")
    var currentPhase = "treble";
    
    // Gibt einen zuf√§lligen Schwellenwert zwischen 2 und 5 zur√ºck
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    var motivationMessages = ["ü•≥", "üéâ", "üéà", "ü™©", "üëë"];
    
    var synth = new Tone.Synth().toDestination();
    
    var rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    function updateScore() {
      var scoreElem = document.getElementById("topRightInfo");
      var percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
      scoreElem.innerHTML = "Score: " + percent + "%<br>" + "Time: " + Date.now();
    }
    window.updateScore = updateScore;
    
    function midiNoteToName(noteNumber) {
      var noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
      var octave = Math.floor(noteNumber / 12) - 1;
      var noteName = noteNames[noteNumber % 12];
      return { note: noteName, octave: octave };
    }
    
    // Angepasste MIDI-Bewertung unter Ber√ºcksichtigung enharmonischer √Ñquivalenz und Schwierigkeitslevel
    function isNoteCorrect(midiInfo) {
      var expected;
      if (selectedMode !== "both") {
        expected = currentSeriesSingle[seriesCounter];
      } else {
        if (currentPhase === "treble") {
          expected = currentSeriesTreble[seriesCounter];
        } else if (currentPhase === "bass") {
          expected = currentSeriesBass[seriesCounter];
        }
      }
      if (!expected) return false;
      
      // Normalisiere beide Noten (in Kleinbuchstaben)
      var playedNote = midiInfo.note.toLowerCase();
      var expectedNote = expected.note.toLowerCase();
      // Falls erwartete Note "bb" ist, akzeptiere auch "a#" als gleichwertig
      if (expectedNote === "bb" && playedNote === "a#") {
        playedNote = expectedNote;
      }
      
      if (level === 1 || level === 3) {
        // Exakter Vergleich: Note UND Oktave
        return (playedNote === expectedNote && midiInfo.octave === expected.octave);
      } else if (level === 2) {
        // Nur Notenbuchstabe wird verglichen, Oktave ignoriert
        return (playedNote === expectedNote);
      } else if (level === "random") {
        return Math.random() < 0.5;
      }
      return false;
    }
    
    function proceedToMainScreen() {
      var welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.transition = "opacity 0.5s ease-out";
      welcomeOverlay.style.opacity = "0";
      setTimeout(function() {
        welcomeOverlay.style.display = "none";
        var mainContent = document.getElementById("mainContent");
        mainContent.style.transition = "opacity 1s ease-in";
        mainContent.style.opacity = "1";
      }, 500);
    }
    
    // Verbesserte MIDI-√úberpr√ºfung: Nutzt Bitmasken, um sicher Note-On (0x90 bis 0x9F) zu erkennen.
    window.handleMIDIMessage = function(status, data1, data2) {
      // Falls status ein Event-Objekt ist
      if (status && status.data) {
        data1 = status.data[1];
        data2 = status.data[2];
        status = status.data[0];
      }
      console.log("handleMIDIMessage:", status, data1, data2);
      if (soundEnabled && ((status & 0xF0) === 144) && data2 > 0) {
        var midiInfo = midiNoteToName(data1);
        var pitch = midiInfo.note.toUpperCase() + midiInfo.octave;
        synth.triggerAttackRelease(pitch, "8n");
        document.getElementById("noteNameDisplay").textContent = pitch;
        
        var isCorrect = isNoteCorrect(midiInfo);
        
        // Setze die Farbe anhand des Ergebnisses: Gr√ºn = korrekt, Rot = falsch
        if (selectedMode !== "both") {
          currentSeriesSingle[seriesCounter].color = isCorrect ? "green" : "red";
          seriesCounter++;
          drawSeries();
          if (seriesCounter >= currentSeriesSingle.length) {
            generateSeries();
          }
        } else {
          if (currentPhase === "treble") {
            currentSeriesTreble[seriesCounter].color = isCorrect ? "green" : "red";
            seriesCounter++;
            drawSeries();
            if (seriesCounter >= currentSeriesTreble.length) {
              currentPhase = "bass";
              seriesCounter = 0;
              drawSeries();
              return;
            }
          } else if (currentPhase === "bass") {
            currentSeriesBass[seriesCounter].color = isCorrect ? "green" : "red";
            seriesCounter++;
            drawSeries();
            if (seriesCounter >= currentSeriesBass.length) {
              generateSeries();
              return;
            }
          }
        }
    
        // Motivations- oder Fehleranzeige
        if (!firstNotePlayed) {
          showMotivation("ü§ü");
          firstNotePlayed = true;
          correctNoteCount = 0;
          nextMotivationThreshold = getRandomThreshold();
        } else {
          if (isCorrect) {
            correctNoteCount++;
            if (correctNoteCount >= nextMotivationThreshold) {
              showMotivation();
              correctNoteCount = 0;
              nextMotivationThreshold = getRandomThreshold();
            }
          } else {
            showMotivation("‚ùå");
          }
        }
      }
    };
    
    function showMotivation(customMessage) {
      var motivationDiv = document.getElementById("motivationOverlay");
      var message = customMessage || motivationMessages[Math.floor(Math.random() * motivationMessages.length)];
      motivationDiv.textContent = message;
      motivationDiv.classList.add("animate-motivation");
      setTimeout(function() {
        motivationDiv.classList.remove("animate-motivation");
      }, 2500);
    }
    
    function generateSeries() {
      seriesCounter = 0;
      firstNotePlayed = false;
      correctNoteCount = 0;
      nextMotivationThreshold = getRandomThreshold();
      
      if (selectedMode !== "both") {
        currentSeriesSingle = [];
        for (var i = 0; i < seriesLength; i++) {
          var randomIndex = Math.floor(Math.random() * rangeNotes[currentRange].length);
          var clef = selectedMode === "left" ? "bass" : "treble";
          var octave = selectedMode === "left" ? 3 : 4;
          currentSeriesSingle.push({ note: rangeNotes[currentRange][randomIndex], octave: octave, clef: clef, color: "black" });
        }
        currentPhase = "single";
        drawSeries();
      } else {
        currentSeriesTreble = [];
        currentSeriesBass = [];
        for (var i = 0; i < seriesLength; i++) {
          var randomIndexT = Math.floor(Math.random() * rangeNotes[currentRange].length);
          var randomIndexB = Math.floor(Math.random() * rangeNotes[currentRange].length);
          currentSeriesTreble.push({ note: rangeNotes[currentRange][randomIndexT], octave: 4, clef: "treble", color: "black" });
          currentSeriesBass.push({ note: rangeNotes[currentRange][randomIndexB], octave: 3, clef: "bass", color: "black" });
        }
        currentPhase = "treble";
        drawSeries();
      }
    }
    
    function drawSeries() {
      if (selectedMode !== "both") {
        var notationDiv = document.getElementById("notation");
        notationDiv.style.display = "block";
        document.getElementById("notationContainer").style.display = "none";
        notationDiv.innerHTML = "";
        var ratio = window.devicePixelRatio || 1;
        var baseWidth = 800;
        var width = baseWidth * ratio;
        var height = 200 * ratio;
        var renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
        renderer.resize(width, height);
        var svg = notationDiv.querySelector("svg");
        if (svg) {
          svg.setAttribute("width", baseWidth);
          svg.setAttribute("height", 200);
        }
        var context = renderer.getContext();
        var stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesSingle.length > 0) {
          stave.addClef(currentSeriesSingle[0].clef).setContext(context).draw();
        }
        var staveNotes = currentSeriesSingle.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: item.clef,
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
        });
        var voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotes.forEach(function(note) { voice.addTickable(note); });
        new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
        voice.draw(context, stave);
      } else {
        var container = document.getElementById("notationContainer");
        container.style.display = "flex";
        container.style.alignItems = "flex-start"; // Systeme linksb√ºndig
        container.innerHTML = "";
        // Erstelle zwei Divs f√ºr Treble und Bass
        var notationTreble = document.createElement("div");
        notationTreble.id = "notationTreble";
        var notationBass = document.createElement("div");
        notationBass.id = "notationBass";
        container.appendChild(notationTreble);
        container.appendChild(notationBass);
    
        // Zeichne Treble-System
        notationTreble.innerHTML = "";
        var ratio = window.devicePixelRatio || 1;
        var baseWidth = 800;
        var width = baseWidth * ratio;
        var height = 200 * ratio;
        var rendererT = new Vex.Flow.Renderer(notationTreble, Vex.Flow.Renderer.Backends.SVG);
        rendererT.resize(width, height);
        var svgT = notationTreble.querySelector("svg");
        if (svgT) {
          svgT.setAttribute("width", baseWidth);
          svgT.setAttribute("height", 200);
        }
        var contextT = rendererT.getContext();
        var staveT = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesTreble.length > 0) {
          staveT.addClef("treble").setContext(contextT).draw();
        }
        var staveNotesT = currentSeriesTreble.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: "treble",
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
        });
        var voiceT = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesT.forEach(function(note) { voiceT.addTickable(note); });
        new Vex.Flow.Formatter().joinVoices([voiceT]).format([voiceT], staveT.getWidth() - 20);
        voiceT.draw(contextT, staveT);
    
        // Zeichne Bass-System
        notationBass.innerHTML = "";
        var rendererB = new Vex.Flow.Renderer(notationBass, Vex.Flow.Renderer.Backends.SVG);
        rendererB.resize(width, height);
        var svgB = notationBass.querySelector("svg");
        if (svgB) {
          svgB.setAttribute("width", baseWidth);
          svgB.setAttribute("height", 200);
        }
        var contextB = rendererB.getContext();
        var staveB = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesBass.length > 0) {
          staveB.addClef("bass").setContext(contextB).draw();
        }
        var staveNotesB = currentSeriesBass.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: "bass",
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
        });
        var voiceB = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesB.forEach(function(note) { voiceB.addTickable(note); });
        new Vex.Flow.Formatter().joinVoices([voiceB]).format([voiceB], staveB.getWidth() - 20);
        voiceB.draw(contextB, staveB);
      }
    }
    
    function cycleRange() {
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
    }
    
    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
    }
    
    // F√ºr Maus und Touch ‚Äì passt die Opacity an
    function setupFadeOnHover(element) {
      element.addEventListener("mouseenter", function() {
        element.classList.remove("faded");
      });
      element.addEventListener("mouseleave", function() {
        element.classList.add("faded");
      });
      element.addEventListener("touchstart", function() {
        element.classList.remove("faded");
      });
      element.addEventListener("touchend", function() {
        element.classList.add("faded");
      });
    }
  </script>
</head>
<body>
  <!-- Welcome Overlay -->
  <div id="welcomeOverlay">
    <div id="welcomeMessage">Hallo, sch√∂n dich zu sehen!<br>V23:45</div>
  </div>
  
  <!-- Motivationsfenster -->
  <div id="motivationOverlay"></div>
  
  <!-- Hauptinhalt -->
  <div id="mainContent" style="opacity: 0;">
    <!-- Einstellungen-Men√º -->
    <div id="settingsPanel" class="expanded">
      <div id="handSettings">
        <!-- Standard: linke Hand (active) -->
        <span id="mode-left" class="active-mode">‚úã</span>
        <span id="mode-right" class="inactive-mode" style="transform: scaleX(-1);">‚úã</span>
        <span id="mode-both" class="inactive-mode">üôå</span>
      </div>
      <br>
      <div id="levelSettings">
        <span id="level-1" class="inactive-level">1Ô∏è‚É£</span>
        <span id="level-2" class="inactive-level">2Ô∏è‚É£</span>
        <span id="level-3" class="active-level">3Ô∏è‚É£</span>
        <span id="level-random" class="inactive-level">üéâ</span>
      </div>
      <br>
      <div id="soundSettings">
        <span id="soundToggle">üîä</span>
        <span id="darkModeToggle">üåô</span>
      </div>
    </div>
    
    <!-- Notationsbereich f√ºr Einhand -->
    <div id="notation"></div>
    <!-- Container f√ºr Beidh√§ndig -->
    <div id="notationContainer"></div>
    
    <!-- Lage-Button (nur im Einhand-Modus) -->
    <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
    
    <!-- Notenname-Anzeige -->
    <div id="noteNameDisplay" style="position: fixed; left: 50%; bottom: 110px; transform: translateX(-50%); font-size: 1.5em;"></div>
    
    <!-- Debug-Ausgabe -->
    <div id="nativeLog"></div>
  </div>
  
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      setTimeout(function() { proceedToMainScreen(); }, 3000);
      generateSeries();
      
      // Hand-Modus-Buttons
      var modeButtons = document.querySelectorAll("#handSettings span");
      modeButtons.forEach(function(btn) {
        btn.addEventListener("click", function() {
          modeButtons.forEach(function(b) {
            b.classList.remove("active-mode");
            b.classList.add("inactive-mode");
          });
          btn.classList.remove("inactive-mode");
          btn.classList.add("active-mode");
          selectedMode = btn.id.split("-")[1];
          generateSeries();
        });
      });
      
      // Level-Buttons
      var levelButtons = document.querySelectorAll("#levelSettings span");
      levelButtons.forEach(function(btn) {
        btn.addEventListener("click", function() {
          levelButtons.forEach(function(b) {
            b.classList.remove("active-level");
            b.classList.add("inactive-level");
          });
          btn.classList.remove("inactive-level");
          btn.classList.add("active-level");
          if (btn.id === "level-1") { level = 1; }
          else if (btn.id === "level-2") { level = 2; }
          else if (btn.id === "level-3") { level = 3; }
          else if (btn.id === "level-random") { level = "random"; }
          generateSeries();
        });
      });
      
      // Sound- und Dark-Mode-Toggle
      var soundToggle = document.getElementById("soundToggle");
      soundToggle.addEventListener("click", function() {
        soundEnabled = !soundEnabled;
        soundToggle.textContent = soundEnabled ? "üîä" : "üîá";
      });
      
      var darkModeToggle = document.getElementById("darkModeToggle");
      darkModeToggle.addEventListener("click", function() {
        toggleDarkMode();
      });
      
      setupFadeOnHover(document.getElementById("settingsPanel"));
      setupFadeOnHover(document.getElementById("clefTitle"));
      
      // Zum Testen: Leertaste l√∂st ein MIDI-Signal aus
      document.addEventListener("keydown", function(event) {
        if (event.code === "Space") {
          handleMIDIMessage(144, 60, 127);
          console.log("Leertaste gedr√ºckt: MIDI Signal gesendet.");
        }
      });
    });
  </script>
</body>
</html>
