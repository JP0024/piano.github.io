<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Notentraining</title>
  <style>
    body { font-family: sans-serif; text-align: center; }
    #notation {
      width: 820px;
      transform: scale(2);
      margin: 0 auto;
      text-align: center;
    }
    .active-mode, .active-level, .active-range {
      opacity: 1;
      font-weight: bold;
      color: black;
    }
    .inactive-mode, .inactive-level, .inactive-range { opacity: 0.5; }
    #nativeLog { margin-top: 10px; font-size: 0.9em; color: gray; }
  </style>
</head>
<body>
  <div id="midiStatus" style="position: absolute; top: 10px; left: 10px; font-size: 1em;"></div>
  <h1>Notentraining</h1>
  <!-- Hier folgen deine Auswahl-Elemente (Range, Mode, Level) und VexFlow-Container -->
  <div id="notation"></div>
  <div id="score">Score: 0%</div>
  <div id="responseTime">üèéÔ∏è -- ms</div>
  <div id="nativeLog"></div>

  <!-- VexFlow einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  
  <script>
    // Diese globale Funktion wird von Swift √ºber evaluateJavaScript aufgerufen.
    // Beispiel-Aufruf in Swift:
    // webView.evaluateJavaScript("handleMIDIMessage(144, 60, 100)", completionHandler: nil)
    window.handleMIDIMessage = function(status, data1, data2) {
      console.log("handleMIDIMessage aufgerufen:", status, data1, data2);
      document.getElementById("nativeLog").textContent =
         "MIDI Nachricht: Status " + status + ", Data1 " + data1 + ", Data2 " + data2;
      
      // Hier wird der Data1-Wert in die aktuelle Note umgewandelt
      var midiInfo = midiNoteToName(data1);
      console.log("Umgewandelte Note:", midiInfo);
      
      // Vergleiche den empfangenen MIDI-Wert mit der aktuell erwarteten Note (aus currentSeries)
      if (seriesCounter < currentSeries.length) {
        var expected = currentSeries[seriesCounter];
        if (midiInfo.note === expected.note && midiInfo.octave === expected.octave) {
          expected.color = "green";
          correctAnswers++;
          document.getElementById("nativeLog").textContent += " - Richtig!";
        } else {
          expected.color = "red";
          document.getElementById("nativeLog").textContent += " - Falsch!";
        }
        totalAttempts++;
        updateScore();
        seriesCounter++;
        // Optionale Logik: Neue Serie generieren, wenn alle Noten abgearbeitet wurden
        if (seriesCounter >= seriesLength) {
          generateSeries();
        }
      }
    };

    // Funktion zur Umrechnung von Data1 in Note und Oktave
    function midiNoteToName(noteNumber) {
      var noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
      var octave = Math.floor(noteNumber / 12) - 1;
      var noteName = noteNames[noteNumber % 12];
      return { note: noteName, octave: octave };
    }

    // Globale Variablen, die auch von handleMIDIMessage genutzt werden
    var currentSeries = [];
    var seriesCounter = 0;
    var seriesLength = 1;
    var totalAttempts = 0;
    var correctAnswers = 0;

    // Beispiel-Funktionen f√ºr Score-Update und Serien-Generierung
    function updateScore() {
      var scoreElem = document.getElementById("score");
      var percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
      scoreElem.textContent = "Score: " + percent + "%";
    }
    
    function generateSeries() {
      // Beispiel: Erzeuge eine Serie mit einer zuf√§lligen Note (hier immer C, D, E, F, G aus der Range "C")
      var rangeNotes = ["c", "d", "e", "f", "g"];
      currentSeries = [];
      seriesCounter = 0;
      seriesLength = 1;  // f√ºr diesen Test eine Note
      var randomIndex = Math.floor(Math.random() * rangeNotes.length);
      // Beispiel: Wir erwarten immer Oktave 4
      currentSeries.push({ note: rangeNotes[randomIndex], octave: 4, clef: "treble", color: "black" });
      drawSeries();
    }
    
    function drawSeries() {
      var notationDiv = document.getElementById("notation");
      notationDiv.innerHTML = "";
      var usedWidth = 80 * seriesLength + 20;
      var renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
      renderer.resize(usedWidth, 200);
      var context = renderer.getContext();
      var stave = new Vex.Flow.Stave(10, 40, usedWidth - 20);
      if (currentSeries.length > 0) {
        stave.addClef(currentSeries[0].clef).setContext(context).draw();
      }
      var staveNotes = currentSeries.map(function(item) {
        return new Vex.Flow.StaveNote({
          clef: item.clef,
          keys: [item.note + "/" + item.octave],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
      });
      var voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
      staveNotes.forEach(function(note) { voice.addTickable(note); });
      new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
      voice.draw(context, stave);
    }

    // Initiale Serien-Generierung beim Laden der Seite
    document.addEventListener("DOMContentLoaded", function() {
      generateSeries();
    });
  </script>
</body>
</html>
