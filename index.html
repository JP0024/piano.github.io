<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
<<<<<<< Updated upstream
  <title>Notentraining</title>
  <link rel="stylesheet" href="./style.css">
=======
  <title>MIDI Note Verification</title>
>>>>>>> Stashed changes
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin-top: 50px;
    }
<<<<<<< Updated upstream
    #notation {
      width: 820px;
      transform: scale(2);
      margin: 0 auto;
      text-align: center;
    }
    .active-mode, .active-level, .active-range {
      opacity: 1;
      font-weight: bold;
      color: black;
    }
    .inactive-mode, .inactive-level, .inactive-range {
      opacity: 0.5;
    }
    #nativeLog {
      margin-top: 10px;
      font-size: 0.9em;
      color: gray;
=======
    #midiInput, #result {
      font-size: 1.5em;
      margin: 20px;
>>>>>>> Stashed changes
    }
  </style>
</head>
<body>
<<<<<<< Updated upstream
  <!-- MIDI-Statusanzeige -->
  <div id="midiStatus" style="position: absolute; top: 10px; left: 10px; font-size: 1em;"></div>
  <!-- √úberschrift -->
  <h1>Notentraining</h1>
  <!-- Range-, Handmodus- und Level-Auswahl -->
  <div id="rangeSelector">
    <span id="range-c" style="cursor: pointer; font-size: 1.5em; margin: 5px;">C-Lage</span>
    <span id="range-d" style="cursor: pointer; font-size: 1.5em; margin: 5px;">D-Lage</span>
    <span id="range-f" style="cursor: pointer; font-size: 1.5em; margin: 5px;">F-Lage</span>
    <span id="range-g" style="cursor: pointer; font-size: 1.5em; margin: 5px;">G-Lage</span>
    <span id="range-mc" style="cursor: pointer; font-size: 1.5em; margin: 5px;">Mittlere C</span>
  </div>
  <br>
  <div id="modeSelector">
    <span id="mode-left" style="cursor: pointer; font-size: 2em; margin: 5px;">‚úã</span>
    <span id="mode-right" style="cursor: pointer; font-size: 2em; margin: 5px; display:inline-block; transform: scaleX(-1);">‚úã</span>
    <span id="mode-both" style="cursor: pointer; font-size: 2em; margin: 5px;">üôå</span>
  </div>
  <br>
  <div id="levelSelector">
    <span id="level-1" style="cursor: pointer; font-size: 2em; margin: 5px;">1Ô∏è‚É£</span>
    <span id="level-2" style="cursor: pointer; font-size: 2em; margin: 5px;">2Ô∏è‚É£</span>
    <span id="level-3" style="cursor: pointer; font-size: 2em; margin: 5px;">3Ô∏è‚É£</span>
    <span id="level-random" style="cursor: pointer; font-size: 2em; margin: 5px;">üéâ</span>
  </div>

  <div id="notation"></div>
  <div id="score">Score: 0%</div>
  <div id="responseTime">üèéÔ∏è -- ms</div>
  <div id="nativeLog"></div>

  <!-- VexFlow einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <script>
    // Diese Funktion wird vom nativen Code aufgerufen, wenn eine MIDI-Nachricht empfangen wird.
    function handleMIDIMessage(status, data1, data2) {
      console.log("Native MIDI Message empfangen:", status, data1, data2);
      document.getElementById("nativeLog").textContent =
         "Empfangene MIDI Nachricht: Status: " + status +
         ", Data1: " + data1 + ", Data2: " + data2;
      // Wir verarbeiten nur Note-On-Nachrichten (Status 144 bis 159) und nur wenn data2 > 0
      if (status >= 144 && status < 160 && data2 > 0) {
        const midiInfo = midiNoteToName(data1);
        processNoteInput(midiInfo.note, midiInfo.octave);
      }
    }
    
    // Konvertiert einen MIDI-Notenwert in Notennamen und Oktave.
    function midiNoteToName(noteNumber) {
      const noteNames = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
      let octave = Math.floor(noteNumber / 12) - 1;
      let noteName = noteNames[noteNumber % 12];
      return { note: noteName, octave: octave };
    }
    
    // Verarbeitet die Noteingabe und aktualisiert die Anzeige.
    function processNoteInput(inputNote, inputOctave) {
      totalAttempts++;
      const expected = currentSeries[seriesCounter];
      const responseTime = Date.now() - noteStartTime;
      responseTimeElem.textContent = "Response Time: " + responseTime + " ms";
      
      if (inputNote === expected.note && inputOctave === expected.octave) {
        correctAnswers++;
        expected.color = "green";
      } else {
        expected.color = "red";
=======
  <h1>MIDI Note Verification</h1>
  <p id="midiInput">Empfangene Note: ‚Äì</p>
  <p id="result">Ergebnis: ‚Äì</p>
  
  <script>
    // Erwartete Note und Oktave zur √úberpr√ºfung
    var expectedNote = "c";
    var expectedOctave = 4;
    
    // Funktion, um den MIDI-Notenwert (Data1) in einen Notennamen und eine Oktave umzuwandeln.
    function midiNoteToName(noteNumber) {
      var noteNames = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
      var octave = Math.floor(noteNumber / 12) - 1;
      var noteName = noteNames[noteNumber % 12];
      return { note: noteName, octave: octave };
    }
    
    // Funktion, die den empfangenen MIDI-Notenwert (Data1) in eine Note umwandelt
    // und diese mit der erwarteten Note vergleicht.
    function verifyNote(noteNumber) {
      var midiInfo = midiNoteToName(noteNumber);
      
      // Ausgabe der empfangenen Note
      document.getElementById("midiInput").textContent =
        "Empfangene Note: " + midiInfo.note.toUpperCase() + " (Oktave " + midiInfo.octave + ")";
      
      // √úberpr√ºfung
      if(midiInfo.note === expectedNote && midiInfo.octave === expectedOctave) {
        document.getElementById("result").textContent = "Ergebnis: Richtig!";
      } else {
        document.getElementById("result").textContent =
          "Ergebnis: Falsch. Erwartet: " + expectedNote.toUpperCase() + " (Oktave " + expectedOctave + ")";
>>>>>>> Stashed changes
      }
      updateScore();
      drawSeries();
      seriesCounter++;
      noteStartTime = Date.now();
      setTimeout(function() {
        if (seriesCounter >= seriesLength) {
          generateSeries();
        }
      }, 500);
    }
    
<<<<<<< Updated upstream
    // Variable Deklarationen und bestehende Logik f√ºr Notentraining
    let currentRange = "C";
    let selectedMode = "right";
    let level = 1;
    let seriesLength = 1;
    let currentSeries = [];
    let seriesCounter = 0;
    let noteStartTime = 0;
    let totalAttempts = 0;
    let correctAnswers = 0;
    
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    // Referenzen auf Elemente
    const scoreElem = document.getElementById("score");
    const responseTimeElem = document.getElementById("responseTime");
    const notationDiv = document.getElementById("notation");
    
    // VexFlow Setup
    const VF = Vex.Flow;
    
    function drawSeries() {
      notationDiv.innerHTML = "";
      const usedWidth = 80 * seriesLength + 20;
      const renderer = new VF.Renderer(notationDiv, VF.Renderer.Backends.SVG);
      renderer.resize(usedWidth, 200);
      const context = renderer.getContext();
      const stave = new VF.Stave(10, 40, usedWidth - 20);
      stave.addClef(currentSeries[0].clef).setContext(context).draw();
      const staveNotes = currentSeries.map(function(item) {
        return new VF.StaveNote({
          clef: item.clef,
          keys: [item.note + "/" + item.octave],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
      });
      const voice = new VF.Voice({ num_beats: seriesLength, beat_value: 4 });
      staveNotes.forEach(note => voice.addTickable(note));
      new VF.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
      voice.draw(context, stave);
    }
    
    function updateScore() {
      let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
      scoreElem.textContent = "Score: " + percent + "%";
    }
    
    function generateSeries() {
      currentSeries = [];
      seriesCounter = 0;
      const notes = rangeNotes[currentRange];
      if (level < 3) {
        for (let i = 0; i < seriesLength; i++) {
          let note = notes[Math.floor(Math.random() * notes.length)];
          let clef, octave;
          if (selectedMode === "right") {
            clef = "treble";
            octave = 4;
          } else if (selectedMode === "left") {
            clef = "bass";
            octave = 3;
          } else if (selectedMode === "both") {
            clef = Math.random() < 0.5 ? "treble" : "bass";
            octave = (clef === "treble") ? 4 : 3;
          }
          currentSeries.push({ note: note, octave: octave, clef: clef, color: "black" });
        }
      } else {
        let currentIndex = Math.floor(Math.random() * notes.length);
        let clef, octave;
        if (selectedMode === "right") {
          clef = "treble";
          octave = 4;
        } else if (selectedMode === "left") {
          clef = "bass";
          octave = 3;
        } else if (selectedMode === "both") {
          clef = Math.random() < 0.5 ? "treble" : "bass";
          octave = (clef === "treble") ? 4 : 3;
        }
        currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
        for (let i = 1; i < seriesLength; i++) {
          const intervals = [1, 2, 3, 4];
          let interval = intervals[Math.floor(Math.random() * intervals.length)];
          let direction = Math.random() < 0.5 ? 1 : -1;
          if (currentIndex + direction * interval < 0 || currentIndex + direction * interval >= notes.length) {
            direction *= -1;
          }
          currentIndex = currentIndex + direction * interval;
          if (selectedMode === "right") {
            clef = "treble";
            octave = 4;
          } else if (selectedMode === "left") {
            clef = "bass";
            octave = 3;
          } else if (selectedMode === "both") {
            clef = Math.random() < 0.5 ? "treble" : "bass";
            octave = (clef === "treble") ? 4 : 3;
          }
          currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
        }
      }
      drawSeries();
      noteStartTime = Date.now();
    }
    
    // Initiale Generierung der Notenserie
    generateSeries();
    
    // Weitere Event Listener f√ºr die Bedienung der App (Range-, Mode-, Level-Auswahl) k√∂nnen hier erg√§nzt werden.
  </script>
  <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
=======
    // Globale Funktion, die von der nativen App aufgerufen wird (√ºber evaluateJavaScript)
    window.handleMIDIMessage = function(status, data1, data2) {
      console.log("MIDI Message received: Status: " + status + " Data1: " + data1 + " Data2: " + data2);
      // Nur Note-On Nachrichten verarbeiten (Status 144 bis 159 und velocity > 0)
      if(status >= 144 && status < 160 && data2 > 0) {
        verifyNote(data1);
      }
    }
    
    // Test: Simuliere einen MIDI-Aufruf nach 2 Sekunden (Data1 = 60 entspricht mittlerem C)
    setTimeout(function() {
      window.handleMIDIMessage(144, 60, 100);
    }, 2000);
  </script>
>>>>>>> Stashed changes
</body>
</html>
