document.addEventListener("DOMContentLoaded", function() {
  // --- Definition der Lagen (hier nur C-Lage) ---
  const lagen = [
    { name: "Mittel-C-Lage", notes: ["c", "d", "e", "f", "g"], rightOctave: 4, leftOctave: 3 }
  ];
  let selectedLageIndex = 0;
  
  // --- Globaler Zustand ---
  let currentSeries = [];  // Array von { note, octave, clef, color }
  let seriesCounter = 0;   // Index der aktuell erwarteten Note in der Serie
  let noteStartTime = 0;   // Zeitstempel für Antwortzeit
  
  // Handmodus: "right", "left" oder "both"
  let selectedMode = "right";
  // Level: 1: 1 Note, 2: 5 Noten, 3: 10 Noten
  let level = 1;
  let seriesLength = 1;
  
  // --- DOM-Elemente ---
  const midiStatusDiv = document.getElementById("midiStatus");
  
  const modeLeft = document.getElementById("mode-left");
  const modeRight = document.getElementById("mode-right");
  const modeBoth = document.getElementById("mode-both");
  
  const level1 = document.getElementById("level-1");
  const level2 = document.getElementById("level-2");
  const level3 = document.getElementById("level-3");
  
  const rangeLeft = document.getElementById("range-left");
  const rangeRight = document.getElementById("range-right");
  const currentRangeElem = document.getElementById("currentRange");
  
  const btnDlage = document.getElementById("btn-dlage");
  
  const notationDiv = document.getElementById("notation");
  const scoreDiv = document.getElementById("score");
  const responseDiv = document.getElementById("responseTime");
  
  // --- Handmodus-Auswahl ---
  modeLeft.addEventListener("click", function() {
    selectedMode = "left";
    setActiveModeIcon("left");
    generateSeries();
  });
  modeRight.addEventListener("click", function() {
    selectedMode = "right";
    setActiveModeIcon("right");
    generateSeries();
  });
  modeBoth.addEventListener("click", function() {
    selectedMode = "both";
    setActiveModeIcon("both");
    generateSeries();
  });
  
  function setActiveModeIcon(mode) {
    modeLeft.classList.add("inactive-mode");
    modeRight.classList.add("inactive-mode");
    modeBoth.classList.add("inactive-mode");
    modeLeft.classList.remove("active-mode");
    modeRight.classList.remove("active-mode");
    modeBoth.classList.remove("active-mode");
    if (mode === "left") {
      modeLeft.classList.remove("inactive-mode");
      modeLeft.classList.add("active-mode");
    } else if (mode === "right") {
      modeRight.classList.remove("inactive-mode");
      modeRight.classList.add("active-mode");
    } else if (mode === "both") {
      modeBoth.classList.remove("inactive-mode");
      modeBoth.classList.add("active-mode");
    }
  }
  
  // --- Level-Auswahl ---
  level1.addEventListener("click", function() {
    level = 1;
    seriesLength = 1;
    seriesCounter = 0;
    setActiveLevel("1");
    generateSeries();
  });
  level2.addEventListener("click", function() {
    level = 2;
    seriesLength = 5;
    seriesCounter = 0;
    setActiveLevel("2");
    generateSeries();
  });
  level3.addEventListener("click", function() {
    level = 3;
    seriesLength = 10;
    seriesCounter = 0;
    setActiveLevel("3");
    generateSeries();
  });
  
  function setActiveLevel(lvl) {
    level1.classList.add("inactive-level");
    level2.classList.add("inactive-level");
    level3.classList.add("inactive-level");
    level1.classList.remove("active-level");
    level2.classList.remove("active-level");
    level3.classList.remove("active-level");
    if (lvl === "1") {
      level1.classList.remove("inactive-level");
      level1.classList.add("active-level");
    } else if (lvl === "2") {
      level2.classList.remove("inactive-level");
      level2.classList.add("active-level");
    } else if (lvl === "3") {
      level3.classList.remove("inactive-level");
      level3.classList.add("active-level");
    }
  }
  
  // --- Lage-Auswahl im h1-Header (hier nur fix "Mittel-C-Lage") ---
  rangeLeft.addEventListener("click", function() {
    currentRangeElem.textContent = "Mittel-C-Lage";
    generateSeries();
  });
  rangeRight.addEventListener("click", function() {
    currentRangeElem.textContent = "Mittel-C-Lage";
    generateSeries();
  });
  
  // Falls ein Button für D-Lage existiert, kannst du diesen ergänzen
  if(btnDlage) {
    btnDlage.addEventListener("click", function() {
      currentRangeElem.textContent = "D-Lage";
      // Beispiel: Hier passt du die Oktaven an – allerdings müsstest du auch das Notenarray ändern,
      // wenn du wirklich die D-Lage darstellen möchtest.
      generateSeriesForD(5, 4);
    });
  }
  
  function generateSeriesForD(rightOct, leftOct) {
    // Beispielhafter Fallback: wir verwenden ein alternatives Notenarray für D-Lage.
    const dLage = { name: "D-Lage", notes: ["d", "e", "f#", "g", "a"], rightOctave: rightOct, leftOctave: leftOct };
    currentSeries = [];
    for (let i = 0; i < seriesLength; i++) {
      let note = dLage.notes[Math.floor(Math.random() * dLage.notes.length)];
      let clef, octave;
      if (selectedMode === "right") {
        clef = "treble";
        octave = dLage.rightOctave;
      } else if (selectedMode === "left") {
        clef = "bass";
        octave = dLage.leftOctave;
      } else {
        if (Math.random() < 0.5) {
          clef = "treble";
          octave = dLage.rightOctave;
        } else {
          clef = "bass";
          octave = dLage.leftOctave;
        }
      }
      currentSeries.push({ note: note, octave: octave, clef: clef, color: "black" });
    }
    drawSeries();
    noteStartTime = Date.now();
  }
  
  // Initiale Anzeige der aktuellen Lage
  currentRangeElem.textContent = "Mittel-C-Lage";
  
  // --- VexFlow: Zeichnet die aktuelle Serie von Noten ---
  function drawSeries() {
    notationDiv.innerHTML = "";
    const usedWidth = 80 * seriesLength + 20;
    const renderer = new VF.Renderer(notationDiv, VF.Renderer.Backends.SVG);
    renderer.resize(usedWidth, 200);
    const context = renderer.getContext();
  
    const stave = new VF.Stave(10, 40, usedWidth - 20);
    // Verwende den Schlüssel der ersten Note der Serie als Referenz
    stave.addClef(currentSeries[0].clef).setContext(context).draw();
  
    const staveNotes = currentSeries.map(function(item) {
      return new VF.StaveNote({
        clef: item.clef,
        keys: [item.note + "/" + item.octave],
        duration: "q"
      }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
    });
  
    const voice = new VF.Voice({ num_beats: seriesLength, beat_value: 4 });
    staveNotes.forEach(note => voice.addTickable(note));
    new VF.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
    voice.draw(context, stave);
  }
  
  // --- Score und Antwortzeit ---
  let totalAttempts = 0;
  let correctAnswers = 0;
  function updateScore() {
    let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
    scoreDiv.textContent = "Score: " + percent + "%";
  }
  
  // --- Serien-Generierung ---
  function generateSeries() {
    currentSeries = [];
    seriesCounter = 0;
    const currentLage = lagen[selectedLageIndex];
    if (level < 3) {
      // Falls "both" ausgewählt ist, wählen wir einmalig einen zufälligen Schlüssel für die gesamte Serie:
      let fixedClef, fixedOctave;
      if (selectedMode === "both") {
        fixedClef = Math.random() < 0.5 ? "treble" : "bass";
        fixedOctave = fixedClef === "treble" ? currentLage.rightOctave : currentLage.leftOctave;
      }
      for (let i = 0; i < seriesLength; i++) {
        let note = currentLage.notes[Math.floor(Math.random() * currentLage.notes.length)];
        let clef, octave;
        if (selectedMode === "right") {
          clef = "treble";
          octave = currentLage.rightOctave;
        } else if (selectedMode === "left") {
          clef = "bass";
          octave = currentLage.leftOctave;
        } else if (selectedMode === "both") {
          clef = fixedClef;
          octave = fixedOctave;
        }
        currentSeries.push({ note: note, octave: octave, clef: clef, color: "black" });
      }
    } else {
      // Level 3: Erzeuge eine Serie von 10 Noten mit Intervallbeziehungen,
      // wobei bei "both" ein fester Schlüssel für die Serie gewählt wird.
      let fixedClef, fixedOctave;
      if (selectedMode === "both") {
        fixedClef = Math.random() < 0.5 ? "treble" : "bass";
        fixedOctave = fixedClef === "treble" ? currentLage.rightOctave : currentLage.leftOctave;
      }
      let currentIndex = Math.floor(Math.random() * currentLage.notes.length);
      let clef, octave;
      if (selectedMode === "right") {
        clef = "treble";
        octave = currentLage.rightOctave;
      } else if (selectedMode === "left") {
        clef = "bass";
        octave = currentLage.leftOctave;
      } else if (selectedMode === "both") {
        clef = fixedClef;
        octave = fixedOctave;
      }
      currentSeries.push({ note: currentLage.notes[currentIndex], octave: octave, clef: clef, color: "black" });
      for (let i = 1; i < seriesLength; i++) {
        const intervals = [1, 2, 3, 4]; // 1: Sekunde, 2: Terz, 3: Quarte, 4: Quinte
        let interval = intervals[Math.floor(Math.random() * intervals.length)];
        let direction = Math.random() < 0.5 ? 1 : -1;
        if (currentIndex + direction * interval < 0 || currentIndex + direction * interval >= currentLage.notes.length) {
          direction *= -1;
        }
        currentIndex = currentIndex + direction * interval;
        if (selectedMode === "right") {
          clef = "treble";
          octave = currentLage.rightOctave;
        } else if (selectedMode === "left") {
          clef = "bass";
          octave = currentLage.leftOctave;
        } else if (selectedMode === "both") {
          clef = fixedClef;
          octave = fixedOctave;
        }
        currentSeries.push({ note: currentLage.notes[currentIndex], octave: octave, clef: clef, color: "black" });
      }
    }
    drawSeries();
    noteStartTime = Date.now();
  }
  
  // --- MIDI-Integration ---
  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
  } else {
    alert("Dein Browser unterstützt das Web MIDI API nicht.");
    generateSeries();
  }
  
  function onMIDISuccess(midiAccess) {
    console.log("MIDI ist bereit!");
    midiStatusDiv.textContent = "🔌";
    const inputs = midiAccess.inputs.values();
    for (let input of inputs) {
      input.onmidimessage = handleMIDIMessage;
    }
    generateSeries();
  }
  
  function onMIDIFailure() {
    alert("Kein Zugriff auf MIDI-Geräte möglich.");
    midiStatusDiv.textContent = "⛔";
    generateSeries();
  }
  
  function midiNoteToName(noteNumber) {
    const noteNames = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
    let octave = Math.floor(noteNumber / 12) - 1;
    let noteName = noteNames[noteNumber % 12];
    return { noteName, octave };
  }
  
  // --- Verarbeitung der MIDI-Nachrichten ---
  function handleMIDIMessage(event) {
    console.log("MIDI-Nachricht:", event.data);
    const [status, data1, data2] = event.data;
    if (status >= 144 && status < 160 && data2 > 0) {
      const midiInfo = midiNoteToName(data1);
      console.log("Empfangene Note:", midiInfo.noteName, midiInfo.octave);
      totalAttempts++;
      const expected = currentSeries[seriesCounter];
      const responseTime = Date.now() - noteStartTime;
      responseDiv.textContent = "Response Time: " + responseTime + " ms";
      
      if (midiInfo.noteName === expected.note && midiInfo.octave === expected.octave) {
        correctAnswers++;
        expected.color = "green";
      } else {
        expected.color = "red";
      }
      updateScore();
      drawSeries();
      seriesCounter++;
      noteStartTime = Date.now();
      setTimeout(function() {
        if (seriesCounter >= seriesLength) {
          generateSeries();
        }
      }, 500);
    }
  }
  
  function updateScore() {
    let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
    scoreDiv.textContent = "Score: " + percent + "%";
  }
});
