<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Notentraining</title>
  <!-- Tone.js laden -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.37/Tone.js"></script>
  <!-- VexFlow laden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #ffffff;
      font-family: sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    /* Notationscontainer (Einhand und Zweihand) ‚Äì immer in der absoluten Mitte */
    #notation, #notationContainer {
      display: none;
      position: fixed;
      left: 50%;
      top: 75%;
      transform: translate(-50%, -50%);
      max-width: 800px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 1;
    }
    /* F√ºr Zweihand: beide Systeme (Treble & Bass) im Container mit Abstand */
    #notationContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      row-gap: 20px;
      height: auto;
    }
    #notationTreble, #notationBass {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }
    #notationTreble { margin-bottom: 5px; }
    /* SVG-Optimierung */
    #notation svg, #notationTreble svg, #notationBass svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
    }
    #notation svg *, #notationTreble svg *, #notationBass svg * {
      vector-effect: non-scaling-stroke;
    }
    /* Im Dark Mode: Inline-Farben (z. B. "red" oder "green") bleiben erhalten */
    body.dark-mode #notation svg *,
    body.dark-mode #notationTreble svg *,
    body.dark-mode #notationBass svg * {
      stroke: #ffffff;
      fill: #ffffff;
    }
    /* Motivationsfenster (ohne Textschatten) */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000000;
      text-shadow: none;
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    /* Game Over Overlay (wird nun auch f√ºr Session-Pause genutzt) */
    #gameOverOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #ffffff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      display: none;
    }
    body.dark-mode #gameOverOverlay {
      border: 3px solid #ffffff;
    }
    /* Timer Container: rechte untere Ecke (zeigt Zeit und Session-Counter) */
    #timerContainer {
      position: fixed;
      right: 10px;
      bottom: 30px;
      font-size: 1.5em;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Hauptinhalt */
    #mainContent {
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease-in;
      padding-bottom: 50px;
    }
    /* Einstellungen-Men√º (links) */
    #settingsPanel {
      position: fixed;
      left: 30px;
      top: 50%;
      transform: translateY(-50%);
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      transition: background 0.3s, border-color 0.3s, color 0.3s;
    }
    body.dark-mode #settingsPanel {
      background: #000000;
      border-color: #ffffff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 8px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    /* Lagewechsel-Button (Einhand) */
    #clefTitle {
      display: inline-block;
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
    }
    body.dark-mode #clefTitle {
      background: #000000;
      border-color: #ffffff;
      color: #ffffff;
    }
    /* Container f√ºr den Lagewechsel-Button und Herzen */
    #buttonContainer {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      z-index: 50;
    }
    /* Container f√ºr Herzen, direkt neben dem Button */
    #heartsContainer {
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
      font-size: 1.5em;
    }
    /* Notenname-Anzeige */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 1.5em;
      color: #000;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #ffffff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    body.dark-mode #welcomeOverlay { background-color: #121212; }
    #welcomeMessage {
      font-size: 2.5em;
      color: #000;
      margin-bottom: 20px;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
    /* Klasse zum Verbergen */
    .hidden {
      display: none !important;
    }
  </style>
  <script>
    // Globale Variablen
    var currentSeriesSingle = [];
    var currentSeriesTreble = [];
    var currentSeriesBass = [];
    var seriesCounter = 0;
    var seriesLength = 5;
    var totalAttempts = 0;
    var correctAnswers = 0;

    // Herz-System: 4 Herzen
    var hearts = 4;
    function updateHeartsDisplay() {
      var heartsElem = document.getElementById("heartsContainer");
      if (unlimitedLives) {
        heartsElem.textContent = "‚àû";
      } else {
        heartsElem.textContent = "‚ù§Ô∏è".repeat(hearts);
      }
    }

    // Neuer Session-Counter (korrekte Noten, startet bei 1000)
    var sessionCounter = 1000;
    var sessionPaused = false;

    // Toggle f√ºr unbegrenzte Leben
    var unlimitedLives = false;

    // Timer: Startzeit bleibt erhalten
    var startTime = Date.now();
    function updateTimer() {
      var elapsed = Math.floor((Date.now() - startTime) / 1000);
      var display;
      if (elapsed < 60) {
        display = elapsed + " s";
      } else {
        var hours = Math.floor(elapsed / 3600);
        var minutes = Math.floor((elapsed % 3600) / 60);
        display = (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes);
      }
      document.getElementById("timerContainer").textContent = display + " | Richtig √ºbrig: " + sessionCounter;
    }
    setInterval(updateTimer, 1000);

    // Spielende
    var gameOver = false;
    function endGame() {
      gameOver = true;
      var gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      setTimeout(resetGame, 5000);
    }
    function resetGame() {
      hearts = 4;
      gameOver = false;
      seriesCounter = 0;
      totalAttempts = 0;
      correctAnswers = 0;
      firstNotePlayed = false;
      correctNoteCount = 0;
      sessionCounter = 1000;
      sessionPaused = false;
      nextMotivationThreshold = getRandomThreshold();
      document.getElementById("gameOverOverlay").style.display = "none";
      generateSeries();
      updateHeartsDisplay();
    }

    // Einstellungen f√ºr Hand, Level und Leben
    var handOptions = [
      { mode: "left", symbol: "‚úã" },
      { mode: "right", symbol: "‚úã", flip: true },
      { mode: "both", symbol: "üôå" }
    ];
    var levelOptions = [
      { level: 1, symbol: "1Ô∏è‚É£" },
      { level: 2, symbol: "2Ô∏è‚É£" },
      { level: 3, symbol: "3Ô∏è‚É£" },
      { level: "random", symbol: "üéâ" }
    ];
    var currentHandIndex = 0;
    var currentLevelIndex = 2;
    var selectedMode = handOptions[currentHandIndex].mode;
    var level = levelOptions[currentLevelIndex].level;

    var rangeArray = ["C", "D", "F", "G", "MC"];
    var currentRangeIndex = 0;
    var currentRange = rangeArray[currentRangeIndex];
    var soundEnabled = true;
    var firstNotePlayed = false;
    var correctNoteCount = 0;
    var nextMotivationThreshold = getRandomThreshold();
    var currentPhase = "treble";

    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }

    var motivationMessages = ["ü•≥", "üéâ", "üéà", "ü™©", "üëë"];
    var synth = new Tone.Synth().toDestination();

    var rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };

    function midiNoteToName(noteNumber) {
      var noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
      var octave = Math.floor(noteNumber / 12) - 1;
      var noteName = noteNames[noteNumber % 12];
      return { note: noteName, octave: octave };
    }

    function isNoteCorrect(midiInfo) {
      var expected;
      if (selectedMode !== "both") {
        expected = currentSeriesSingle[seriesCounter];
      } else {
        expected = currentPhase === "treble" ? currentSeriesTreble[seriesCounter] : currentSeriesBass[seriesCounter];
      }
      if (!expected) return false;
      var playedNote = midiInfo.note.toLowerCase();
      var expectedNote = expected.note.toLowerCase();
      if (expectedNote === "bb" && playedNote === "a#") {
        playedNote = expectedNote;
      }
      if (level === 1 || level === 3) {
        return (playedNote === expectedNote && midiInfo.octave === expected.octave);
      } else if (level === 2) {
        return (playedNote === expectedNote);
      } else if (level === "random") {
        return Math.random() < 0.5;
      }
      return false;
    }

    function proceedToMainScreen() {
      var welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(function() {
        welcomeOverlay.classList.add("hidden");
        document.getElementById("mainContent").style.opacity = "1";
      }, 500);
    }

    // Der Lagewechsel-Button: Wechselt die "Lage" und erzeugt neue Notation
    function cycleRange() {
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
    }

    function setupFadeOnHover(element) {
      element.addEventListener("mouseenter", function() { element.classList.remove("faded"); });
      element.addEventListener("mouseleave", function() { element.classList.add("faded"); });
      element.addEventListener("touchstart", function() { element.classList.remove("faded"); });
      element.addEventListener("touchend", function() { element.classList.add("faded"); });
    }

    // Throttling: Neuzeichnen wird √ºber requestAnimationFrame gesteuert
    var redrawQueued = false;
    function queueRedraw() {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(function() {
          drawSeries();
          redrawQueued = false;
        });
      }
    }

    document.addEventListener("DOMContentLoaded", function() {
      var settingsPanel = document.getElementById("settingsPanel");
      var handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      if (handOptions[currentHandIndex].flip) {
        handToggle.style.transform = "scaleX(-1)";
      }
      settingsPanel.appendChild(handToggle);

      var levelToggle = document.createElement("span");
      levelToggle.id = "levelToggle";
      levelToggle.textContent = levelOptions[currentLevelIndex].symbol;
      settingsPanel.appendChild(levelToggle);

      var soundToggle = document.createElement("span");
      soundToggle.id = "soundToggle";
      soundToggle.textContent = "üîä";
      settingsPanel.appendChild(soundToggle);

      // Neuer Toggle f√ºr Leben: Mit Klick auf ‚≠ê wird der Herzen-Modus deaktiviert (unbegrenzte Leben)
      var lifeToggle = document.createElement("span");
      lifeToggle.id = "lifeToggle";
      lifeToggle.textContent = "‚≠ê";
      settingsPanel.appendChild(lifeToggle);
      lifeToggle.addEventListener("click", function() {
        unlimitedLives = !unlimitedLives;
        if (unlimitedLives) {
          lifeToggle.textContent = "‚àû";
          document.getElementById("heartsContainer").textContent = "‚àû";
        } else {
          lifeToggle.textContent = "‚≠ê";
          updateHeartsDisplay();
        }
      });

      var darkModeToggle = document.createElement("span");
      darkModeToggle.id = "darkModeToggle";
      darkModeToggle.textContent = "üåô";
      settingsPanel.appendChild(darkModeToggle);

      handToggle.addEventListener("click", function() {
        currentHandIndex = (currentHandIndex + 1) % handOptions.length;
        selectedMode = handOptions[currentHandIndex].mode;
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
        generateSeries();
      });

      levelToggle.addEventListener("click", function() {
        currentLevelIndex = (currentLevelIndex + 1) % levelOptions.length;
        level = levelOptions[currentLevelIndex].level;
        levelToggle.textContent = levelOptions[currentLevelIndex].symbol;
        generateSeries();
      });

      soundToggle.addEventListener("click", function() {
        soundEnabled = !soundEnabled;
        soundToggle.textContent = soundEnabled ? "üîä" : "üîá";
      });

      darkModeToggle.addEventListener("click", function() {
        toggleDarkMode();
      });

      setupFadeOnHover(settingsPanel);
      setupFadeOnHover(document.getElementById("clefTitle"));

      setTimeout(proceedToMainScreen, 3000);
      generateSeries();
      updateHeartsDisplay();

      document.addEventListener("keydown", function(event) {
        if (event.code === "Space") {
          handleMIDIMessage(144, 60, 127);
          console.log("Leertaste gedr√ºckt: MIDI Signal gesendet.");
        }
      });
    });

    // Hier wurde die Note-Generierung optimiert, indem auch die Oktaven zuf√§llig gew√§hlt werden.
    function generateSeries() {
      seriesCounter = 0;
      firstNotePlayed = false;
      correctNoteCount = 0;
      nextMotivationThreshold = getRandomThreshold();

      if (selectedMode !== "both") {
        currentSeriesSingle = [];
        // F√ºr Single-Mode: Bei "left" (Bass) w√§hle zuf√§llig zwischen Oktaven 2 und 3, sonst (Treble) zwischen 4 und 5.
        var possibleOctaves = (selectedMode === "left") ? [2, 3] : [4, 5];
        for (var i = 0; i < seriesLength; i++) {
          var randomIndex = Math.floor(Math.random() * rangeNotes[currentRange].length);
          var clef = (selectedMode === "left") ? "bass" : "treble";
          var octave = possibleOctaves[Math.floor(Math.random() * possibleOctaves.length)];
          currentSeriesSingle.push({
            note: rangeNotes[currentRange][randomIndex],
            octave: octave,
            clef: clef,
            color: "black"
          });
        }
        currentPhase = "single";
        drawSeries();
      } else {
        currentSeriesTreble = [];
        currentSeriesBass = [];
        // F√ºr Zweihandmodus: Treble erh√§lt zuf√§llig Oktaven 4 oder 5, Bass erh√§lt 2 oder 3.
        for (var i = 0; i < seriesLength; i++) {
          var randomIndexT = Math.floor(Math.random() * rangeNotes[currentRange].length);
          var randomIndexB = Math.floor(Math.random() * rangeNotes[currentRange].length);
          var octaveT = Math.random() < 0.5 ? 4 : 5;
          var octaveB = Math.random() < 0.5 ? 2 : 3;
          currentSeriesTreble.push({
            note: rangeNotes[currentRange][randomIndexT],
            octave: octaveT,
            clef: "treble",
            color: "black"
          });
          currentSeriesBass.push({
            note: rangeNotes[currentRange][randomIndexB],
            octave: octaveB,
            clef: "bass",
            color: "black"
          });
        }
        currentPhase = "treble";
        drawSeries();
      }
    }

    function drawSeries() {
      var notationDiv = document.getElementById("notation");
      var container = document.getElementById("notationContainer");

      if (selectedMode !== "both") {
        notationDiv.style.display = "block";
        notationDiv.innerHTML = "";
        container.style.display = "none";
        container.innerHTML = "";

        var ratio = window.devicePixelRatio || 1;
        var baseWidth = 800;
        var width = baseWidth * ratio;
        var height = 300 * ratio;
        var renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
        renderer.resize(width, height);

        var svg = notationDiv.querySelector("svg");
        if (svg) {
          svg.setAttribute("width", baseWidth);
          svg.setAttribute("height", 300);
        }

        var context = renderer.getContext();
        var stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesSingle.length > 0) {
          stave.addClef(currentSeriesSingle[0].clef).setContext(context).draw();
        }
        var staveNotes = currentSeriesSingle.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: item.clef,
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({
            fillStyle: item.color,
            strokeStyle: item.color
          });
        });

        var voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotes.forEach(function(note) {
          voice.addTickable(note);
        });
        new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
        voice.draw(context, stave);

      } else {
        container.style.display = "flex";
        container.innerHTML = "";
        notationDiv.style.display = "none";
        notationDiv.innerHTML = "";

        var ratio = window.devicePixelRatio || 1;
        var baseWidth = 800;
        var width = baseWidth * ratio;
        var height = 300 * ratio;

        var notationTreble = document.createElement("div");
        notationTreble.id = "notationTreble";
        container.appendChild(notationTreble);

        var rendererT = new Vex.Flow.Renderer(notationTreble, Vex.Flow.Renderer.Backends.SVG);
        rendererT.resize(width, height);
        var svgT = notationTreble.querySelector("svg");
        if (svgT) {
          svgT.setAttribute("width", baseWidth);
          svgT.setAttribute("height", 300);
        }
        var contextT = rendererT.getContext();
        var staveT = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesTreble.length > 0) {
          staveT.addClef("treble").setContext(contextT).draw();
        }
        var staveNotesT = currentSeriesTreble.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: "treble",
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({
            fillStyle: item.color,
            strokeStyle: item.color
          });
        });
        var voiceT = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesT.forEach(function(note) {
          voiceT.addTickable(note);
        });
        new Vex.Flow.Formatter().joinVoices([voiceT]).format([voiceT], staveT.getWidth() - 20);
        voiceT.draw(contextT, staveT);

        var notationBass = document.createElement("div");
        notationBass.id = "notationBass";
        container.appendChild(notationBass);

        var rendererB = new Vex.Flow.Renderer(notationBass, Vex.Flow.Renderer.Backends.SVG);
        rendererB.resize(width, height);
        var svgB = notationBass.querySelector("svg");
        if (svgB) {
          svgB.setAttribute("width", baseWidth);
          svgB.setAttribute("height", 300);
        }
        var contextB = rendererB.getContext();
        var staveB = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        if (currentSeriesBass.length > 0) {
          staveB.addClef("bass").setContext(contextB).draw();
        }
        var staveNotesB = currentSeriesBass.map(function(item) {
          return new Vex.Flow.StaveNote({
            clef: "bass",
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({
            fillStyle: item.color,
            strokeStyle: item.color
          });
        });
        var voiceB = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesB.forEach(function(note) {
          voiceB.addTickable(note);
        });
        new Vex.Flow.Formatter().joinVoices([voiceB]).format([voiceB], staveB.getWidth() - 20);
        voiceB.draw(contextB, staveB);
      }
    }

    // Optimierte Funktion zur Verarbeitung, Bewertung, Farbanpassung und Fortschaltung der Note
    function handleMIDIMessage(status, data1, data2) {
      if (sessionPaused) return;
      
      console.log("MIDI Message Received: status=" + status + ", data1=" + data1 + ", data2=" + data2);
      if ((status & 0xf0) === 0x90 && data2 > 0) {
        var midiInfo = midiNoteToName(data1);
        var noteName = midiInfo.note + midiInfo.octave;
        var noteDisplay = document.getElementById("noteNameDisplay");
        if (noteDisplay) {
          noteDisplay.textContent = noteName;
        }
        synth.triggerAttackRelease(noteName, "8n");
        
        totalAttempts++;
        var correct = isNoteCorrect(midiInfo);
        if (correct) {
          if (selectedMode !== "both") {
            currentSeriesSingle[seriesCounter].color = "green";
          } else {
            if (currentPhase === "treble") {
              currentSeriesTreble[seriesCounter].color = "green";
            } else {
              currentSeriesBass[seriesCounter].color = "green";
            }
          }
          correctAnswers++;
          sessionCounter--;
          if (sessionCounter <= 0) {
            sessionCounter = 0;
            sessionPaused = true;
            var overlay = document.getElementById("gameOverOverlay");
            overlay.textContent = "Session pausieren";
            overlay.style.display = "block";
            updateTimer();
            return;
          }
        } else {
          if (selectedMode !== "both") {
            currentSeriesSingle[seriesCounter].color = "red";
          } else {
            if (currentPhase === "treble") {
              currentSeriesTreble[seriesCounter].color = "red";
            } else {
              currentSeriesBass[seriesCounter].color = "red";
            }
          }
          if (!unlimitedLives) {
            hearts--;
            updateHeartsDisplay();
            if (hearts <= 0) {
              endGame();
              return;
            }
          }
        }
        seriesCounter++;
        if (seriesCounter >= seriesLength) {
          queueRedraw();
          setTimeout(generateSeries, 300);
        } else {
          queueRedraw();
        }
        updateTimer();
      }
    }
  </script>
</head>
<body>
  <!-- Welcome Overlay -->
  <div id="welcomeOverlay">
    <div id="welcomeMessage">Hallo, sch√∂n dich zu sehen!<br>V23:45</div>
  </div>

  <!-- Game Over / Session-Pause Overlay -->
  <div id="gameOverOverlay"></div>

  <!-- Motivationsfenster -->
  <div id="motivationOverlay"></div>

  <!-- Timer Container -->
  <div id="timerContainer"></div>

  <!-- Hauptinhalt -->
  <div id="mainContent" style="opacity: 0;">
    <!-- Notation (Einhand) -->
    <div id="notation"></div>
    <!-- Container (Zweihand) -->
    <div id="notationContainer"></div>

    <!-- Lagewechsel-Button & Herzen -->
    <div id="buttonContainer" style="z-index:50;">
      <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
      <div id="heartsContainer" style="margin-left:10px;"></div>
    </div>

    <!-- Notenname-Anzeige -->
    <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:1.5em;"></div>
  </div>

  <!-- Einstellungen-Men√º -->
  <div id="settingsPanel"></div>
</body>
</html>
