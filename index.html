<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Notentraining</title>
  <!-- Tone.js laden -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.37/Tone.js"></script>
  <!-- VexFlow laden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <!-- canvas-confetti laden -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #ffffff;
      font-family: sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    /* Einhand-Notation (einzelnes System) */
    #notation {
      display: none;
      position: fixed;
      left: 50%;
      top: 75%;
      transform: translate(-50%, -50%);
      max-width: 800px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 1;
    }
    /* Container für den 2-Handmodus – relative Positionierung */
    #notationContainer {
      display: none;
      position: relative;
      width: 800px;
      height: 400px; /* Höhe anpassen, damit beide Systeme Platz haben */
      left: 50%;
      top: 75%;
      transform: translate(-50%, -50%);
      padding: 10px;
      box-sizing: border-box;
      z-index: 2;
    }
    /* Treble-System: obere Ebene – hier mit Prozentwerten relativ zum Container,
       sodass es wie die obere Zeile eines Musikhefts wirkt */
    #notationTreble {
      position: absolute;
      top: 105%;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 1200px;
      z-index: 2;
    }
    /* Bass-System: untere Ebene */
    #notationBass {
      position: absolute;
      top: 130%;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 1200px;
      z-index: 1;
    }
    /* SVG-Optimierung */
    #notation svg, #notationTreble svg, #notationBass svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
    }
    #notation svg *, #notationTreble svg *, #notationBass svg * {
      vector-effect: non-scaling-stroke;
    }
    /* Im Dark Mode: weiße Stroke/Füllung */
    body.dark-mode #notation svg *,
    body.dark-mode #notationTreble svg *,
    body.dark-mode #notationBass svg * {
      stroke: #ffffff;
      fill: #ffffff;
    }
    /* Motivationsfenster */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000000;
      text-shadow: none;
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    /* Game Over Overlay (auch für Session-Pause) */
    #gameOverOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #ffffff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: none;
    }
    body.dark-mode #gameOverOverlay {
      border: 3px solid #ffffff;
    }
    /* Scoreboard Overlay – ähnlich wie Game Over Overlay */
    #scoreboardOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #ffffff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: block;
    }
    .hidden {
      display: none !important;
    }
    /* Timer Container: rechte untere Ecke (zeigt Zeit und Session-Counter) */
    #timerContainer {
      position: fixed;
      right: 10px;
      bottom: 30px;
      font-size: 1.5em;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Hauptinhalt */
    #mainContent {
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease-in;
      padding-bottom: 50px;
    }
    /* Einstellungen-Menü (links) */
    #settingsPanel {
      position: fixed;
      left: 30px;
      top: 50%;
      transform: translateY(-50%);
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      transition: background 0.3s, border-color 0.3s, color 0.3s;
    }
    body.dark-mode #settingsPanel {
      background: #000000;
      border-color: #ffffff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 8px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    /* Lagewechsel-Button (Einhand) */
    #clefTitle {
      display: inline-block;
      background: #ffffff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
    }
    body.dark-mode #clefTitle {
      background: #000000;
      border-color: #ffffff;
      color: #ffffff;
    }
    /* Container für den Lagewechsel-Button und Herzen */
    #buttonContainer {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      z-index: 50;
    }
    /* Container für Herzen, direkt neben dem Button */
    #heartsContainer {
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
      font-size: 1.5em;
    }
    /* Notenname-Anzeige */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 1.5em;
      color: #000;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #ffffff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    body.dark-mode #welcomeOverlay { background-color: #121212; }
    #welcomeMessage {
      font-size: 2.5em;
      color: #000;
      margin-bottom: 20px;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
  </style>
  <script>
    /****************** Adaptive Pause Script ******************/
    function calculateAdaptiveBreakTime(responseTimes, hitRate) {
      if (responseTimes.length === 0) return 5;
      let sum = responseTimes.reduce((acc, time) => acc + time, 0);
      let avgResponseTime = sum / responseTimes.length;
      const baseline = 500; // in ms
      let slowdownFactor = avgResponseTime / baseline;
      let fatigueIndex = slowdownFactor * (1 - hitRate);
      const basePause = 10;
      let breakTime = basePause * fatigueIndex;
      breakTime = Math.max(5, Math.min(breakTime, 300));
      return breakTime;
    }
    /************************************************************/
    
    // Globale Variablen und initiale Zustände
    let currentSeriesSingle = [];
    let currentSeriesTreble = [];
    let currentSeriesBass = [];
    let seriesCounter = 0;
    const seriesLength = 5;
    let totalAttempts = 0;
    let correctAnswers = 0;
    let correctNoteCount = 0;
    let nextMotivationThreshold = getRandomThreshold();
    let errorNotes = [];
    let responseTimes = [];
    let lastNoteTimestamp = Date.now();
    let appStartTime = Date.now();
    let sessionCounter = 1000;
    let sessionPaused = false;
    let scoreRecorded = false;
    let sessionCount = 0;
    
    // Globales Objekt für das Notenpaar im Zweihandmodus
    let pairInputs = { treble: false, bass: false, firstNoteTime: 0 };
    
    // Herz-System: 4 Herzen
    let hearts = 4;
    const updateHeartsDisplay = () => {
      const heartsElem = document.getElementById("heartsContainer");
      if (unlimitedLives) {
        heartsElem.textContent = "∞";
      } else {
        heartsElem.textContent = "❤️".repeat(hearts);
      }
    };
    
    let unlimitedLives = true;
    
    const updateTimer = () => {
      const elapsed = Math.floor((Date.now() - appStartTime) / 1000);
      let display;
      if (elapsed < 60) {
        display = elapsed + " s";
      } else {
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        display = (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes);
      }
      document.getElementById("timerContainer").textContent = display + " | " + sessionCounter;
    };
    setInterval(updateTimer, 1000);
    
    let pauseRemaining = 0;
    let pauseInterval = null;
    let confettiShown = false;
    
    const updatePauseOverlay = () => {
      const now = new Date();
      let hours = now.getHours();
      let minutes = now.getMinutes();
      hours = hours < 10 ? "0" + hours : hours;
      minutes = minutes < 10 ? "0" + minutes : minutes;
      const timeString = hours + ":" + minutes;
      const quotePercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
      const pauseString = (pauseRemaining < 10 ? "0" + pauseRemaining : pauseRemaining);
      const overlay = document.getElementById("gameOverOverlay");
      overlay.textContent = "SESSION " + sessionCount + " PAUSIERT\n\nZEIT:\t" + timeString +
                            "\nQUOTE:\t" + quotePercent + "%\n\nPAUSE:\t" + pauseString + " s";
    };
    
    const startPauseCountdown = () => {
      sessionPaused = true;
      sessionCount++;
      const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
      pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
      if (!confettiShown) {
         confetti();
         confettiShown = true;
      }
      const overlay = document.getElementById("gameOverOverlay");
      overlay.style.display = "block";
      updatePauseOverlay();
      pauseInterval = setInterval(() => {
           pauseRemaining--;
           if (pauseRemaining <= 0) {
               clearInterval(pauseInterval);
               endPause();
           } else {
               updatePauseOverlay();
           }
      }, 1000);
    };
    
    const endPause = () => {
      const overlay = document.getElementById("gameOverOverlay");
      overlay.style.display = "none";
      sessionPaused = false;
      if (soundEnabled) {
         const gongAudio = document.getElementById("gongSound");
         gongAudio && gongAudio.play();
      }
      if (!scoreRecorded) recordScore();
      resetGame();
    };
    
    let gameOver = false;
    const endGame = () => {
      gameOver = true;
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      if (!scoreRecorded) recordScore();
      setTimeout(resetGame, 5000);
    };
    
    const recordScore = () => {
      if (totalAttempts <= 0) return;
      const durationMs = Date.now() - appStartTime;
      const secondsTotal = Math.floor(durationMs / 1000);
      const minutes = Math.floor(secondsTotal / 60);
      const seconds = secondsTotal % 60;
      const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
      const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
      const now = new Date();
      let dd = now.getDate();
      let mm = now.getMonth() + 1;
      dd = dd < 10 ? "0" + dd : dd;
      mm = mm < 10 ? "0" + mm : mm;
      const dateStr = dd + "." + mm;
      const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: selectedMode };
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      highScores.push(scoreObj);
      highScores.sort((a, b) => {
        if (b.accuracy !== a.accuracy) return b.accuracy - a.accuracy;
        return a.seconds - b.seconds;
      });
      highScores = highScores.slice(0, 5);
      localStorage.setItem("highScores", JSON.stringify(highScores));
      scoreRecorded = true;
    };
    
    const updateScoreboard = () => {
      const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const filtered = allScores.filter(score => score.mode === selectedMode);
      let html = "HIGHSCORES (" + selectedMode + ")\n";
      filtered.forEach((score, index) => {
        html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
      });
      document.getElementById("scoreboardOverlay").textContent = html;
    };
    
    const toggleScoreboard = () => {
      const overlay = document.getElementById("scoreboardOverlay");
      if (overlay.classList.contains("hidden")) {
        overlay.classList.remove("hidden");
        updateScoreboard();
      } else {
        overlay.classList.add("hidden");
      }
    };
    
    const handOptions = [
      { mode: "left", symbol: "✋" },
      { mode: "right", symbol: "✋", flip: true },
      { mode: "both", symbol: "🙌" }
    ];
    const levelOptions = [
      { level: 1, symbol: "1️⃣" },
      { level: 2, symbol: "2️⃣" },
      { level: 3, symbol: "3️⃣" },
      { level: "random", symbol: "🎉" }
    ];
    let currentHandIndex = 0;
    let currentLevelIndex = 2;
    let selectedMode = handOptions[currentHandIndex].mode;
    let level = levelOptions[currentLevelIndex].level;
    
    const rangeArray = ["C", "D", "F", "G", "MC"];
    let currentRangeIndex = 0;
    let currentRange = rangeArray[currentRangeIndex];
    let soundEnabled = true;
    let firstNotePlayed = false;
    // Für den Zweihandmodus setzen wir currentPhase auf "pair"
    let currentPhase = "pair";
    
    const motivationMessages = ["🥳", "🎉", "🎈", "🪩", "👑"];
    const showMotivationMessage = () => {
      const overlay = document.getElementById("motivationOverlay");
      const msg = motivationMessages[Math.floor(Math.random() * motivationMessages.length)];
      overlay.textContent = msg;
      overlay.classList.add("animate-motivation");
      setTimeout(() => {
        overlay.classList.remove("animate-motivation");
        overlay.textContent = "";
      }, 2500);
    };
    
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    const synth = new Tone.Synth().toDestination();
    
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    // Hilfsfunktion: Prüft, ob die eingespielte Note der erwarteten Note für den angegebenen Clef entspricht.
    function isNoteCorrectForClef(midiInfo, expected) {
      if (!expected) return false;
      let playedNote = midiInfo.note.toLowerCase();
      let expectedNote = expected.note.toLowerCase();
      if (expectedNote === "bb" && playedNote === "a#") {
        playedNote = expectedNote;
      }
      if (level === 1 || level === 3) {
        return playedNote === expectedNote && midiInfo.octave === expected.octave;
      } else if (level === 2) {
        return playedNote === expectedNote;
      } else if (level === "random") {
        return Math.random() < 0.5;
      }
      return false;
    }
    
    const removeFromErrorNotes = (noteObj) => {
      errorNotes = errorNotes.filter(n => !(n.note === noteObj.note && n.octave === noteObj.octave && n.clef === noteObj.clef));
    };
    
    const proceedToMainScreen = () => {
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(() => {
        welcomeOverlay.classList.add("hidden");
        document.getElementById("mainContent").style.opacity = "1";
      }, 500);
    };
    
    const autoSelectMode = () => {
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const leftScores = highScores.filter(score => score.mode === "left");
      const rightScores = highScores.filter(score => score.mode === "right");
      const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
      const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
      if (bestLeft < bestRight) {
        selectedMode = "left";
        currentHandIndex = 0;
      } else if (bestRight < bestLeft) {
        selectedMode = "right";
        currentHandIndex = 1;
      } else {
        selectedMode = "left";
        currentHandIndex = 0;
      }
      const handToggle = document.getElementById("handToggle");
      if (handToggle) {
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      }
    };
    
    const cycleRange = () => {
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    };
    
    const toggleDarkMode = () => {
      document.body.classList.toggle("dark-mode");
    };
    
    const setupFadeOnHover = (element) => {
      element.addEventListener("mouseenter", () => element.classList.remove("faded"));
      element.addEventListener("mouseleave", () => element.classList.add("faded"));
      element.addEventListener("touchstart", () => element.classList.remove("faded"));
      element.addEventListener("touchend", () => element.classList.add("faded"));
    };
    
    let redrawQueued = false;
    const queueRedraw = () => {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(() => {
          drawSeries();
          redrawQueued = false;
        });
      }
    };
    
    document.addEventListener("DOMContentLoaded", () => {
      const settingsPanel = document.getElementById("settingsPanel");
      
      const handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      settingsPanel.appendChild(handToggle);
      
      const levelToggle = document.createElement("span");
      levelToggle.id = "levelToggle";
      levelToggle.textContent = levelOptions[currentLevelIndex].symbol;
      settingsPanel.appendChild(levelToggle);
      
      const soundToggle = document.createElement("span");
      soundToggle.id = "soundToggle";
      soundToggle.textContent = "🔊";
      settingsPanel.appendChild(soundToggle);
      
      const lifeToggle = document.createElement("span");
      lifeToggle.id = "lifeToggle";
      lifeToggle.textContent = "∞";
      settingsPanel.appendChild(lifeToggle);
      lifeToggle.addEventListener("click", () => {
        unlimitedLives = !unlimitedLives;
        if (unlimitedLives) {
          lifeToggle.textContent = "∞";
          document.getElementById("heartsContainer").textContent = "∞";
        } else {
          lifeToggle.textContent = "⭐";
          updateHeartsDisplay();
        }
      });
      
      const darkModeToggle = document.createElement("span");
      darkModeToggle.id = "darkModeToggle";
      darkModeToggle.textContent = "🌙";
      settingsPanel.appendChild(darkModeToggle);
      
      const scoreboardToggle = document.createElement("span");
      scoreboardToggle.id = "scoreboardToggle";
      scoreboardToggle.textContent = "🎯";
      settingsPanel.appendChild(scoreboardToggle);
      
      handToggle.addEventListener("click", () => {
        currentHandIndex = (currentHandIndex + 1) % handOptions.length;
        selectedMode = handOptions[currentHandIndex].mode;
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
        generateSeries();
      });
      levelToggle.addEventListener("click", () => {
        currentLevelIndex = (currentLevelIndex + 1) % levelOptions.length;
        level = levelOptions[currentLevelIndex].level;
        levelToggle.textContent = levelOptions[currentLevelIndex].symbol;
        generateSeries();
      });
      soundToggle.addEventListener("click", () => {
        soundEnabled = !soundEnabled;
        soundToggle.textContent = soundEnabled ? "🔊" : "🔇";
      });
      darkModeToggle.addEventListener("click", toggleDarkMode);
      scoreboardToggle.addEventListener("click", toggleScoreboard);
      
      setupFadeOnHover(settingsPanel);
      setupFadeOnHover(document.getElementById("clefTitle"));
      
      autoSelectMode();
      
      setTimeout(proceedToMainScreen, 3000);
      generateSeries();
      updateHeartsDisplay();
      
      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          handleMIDIMessage(144, 60, 127);
        }
      });
      
      document.getElementById("scoreboardOverlay").addEventListener("click", toggleScoreboard);
    });
    
    const generateSeries = () => {
      seriesCounter = 0;
      correctNoteCount = 0;
      nextMotivationThreshold = getRandomThreshold();
      const chooseNote = (clef) => {
        const errorsForClef = errorNotes.filter(n => n.clef === clef);
        if (errorsForClef.length > 0 && Math.random() < 0.6) {
          return errorNotes.splice(errorNotes.indexOf(errorsForClef[0]), 1)[0];
        } else {
          const randomIndex = Math.floor(Math.random() * rangeNotes[currentRange].length);
          return {
            note: rangeNotes[currentRange][randomIndex],
            octave: (selectedMode === "left" || clef === "bass") ? 3 : 4,
            clef: clef,
            color: "black"
          };
        }
      };
      
      if (selectedMode !== "both") {
        currentSeriesSingle = [];
        const clef = selectedMode === "left" ? "bass" : "treble";
        for (let i = 0; i < seriesLength; i++) {
          currentSeriesSingle.push(chooseNote(clef));
        }
        currentPhase = "single";
        drawSeries();
      } else {
        currentSeriesTreble = [];
        currentSeriesBass = [];
        for (let i = 0; i < seriesLength; i++) {
          currentSeriesTreble.push(chooseNote("treble"));
          currentSeriesBass.push(chooseNote("bass"));
        }
        pairInputs = { treble: false, bass: false, firstNoteTime: 0 };
        currentPhase = "pair";
        drawSeries();
      }
    };
    
    const drawSeries = () => {
      const notationDiv = document.getElementById("notation");
      const container = document.getElementById("notationContainer");
      const ratio = window.devicePixelRatio || 1;
      const baseWidth = 800;
      const width = baseWidth * ratio;
      const height = 300 * ratio;
      
      if (selectedMode !== "both") {
        notationDiv.style.display = "block";
        notationDiv.innerHTML = "";
        container.style.display = "none";
        container.innerHTML = "";
        
        const renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
        renderer.resize(width, height);
        const svg = notationDiv.querySelector("svg");
        svg && (svg.setAttribute("width", baseWidth), svg.setAttribute("height", 300));
        const context = renderer.getContext();
        const stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        currentSeriesSingle.length && stave.addClef(currentSeriesSingle[0].clef).setContext(context).draw();
        const staveNotes = currentSeriesSingle.map(item => new Vex.Flow.StaveNote({
          clef: item.clef,
          keys: [item.note + "/" + item.octave],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color }));
        const voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotes.forEach(note => voice.addTickable(note));
        new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
        voice.draw(context, stave);
      } else {
        container.style.display = "block";
        container.innerHTML = "";
        notationDiv.style.display = "none";
        notationDiv.innerHTML = "";
        
        // Treble-System (obere Zeile)
        const notationTreble = document.createElement("div");
        notationTreble.id = "notationTreble";
        container.appendChild(notationTreble);
        const rendererT = new Vex.Flow.Renderer(notationTreble, Vex.Flow.Renderer.Backends.SVG);
        rendererT.resize(width, height);
        const svgT = notationTreble.querySelector("svg");
        svgT && (svgT.setAttribute("width", baseWidth), svgT.setAttribute("height", 300));
        const contextT = rendererT.getContext();
        const staveT = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        currentSeriesTreble.length && staveT.addClef("treble").setContext(contextT).draw();
        const staveNotesT = currentSeriesTreble.map(item => new Vex.Flow.StaveNote({
          clef: "treble",
          keys: [item.note + "/" + item.octave],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color }));
        const voiceT = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesT.forEach(note => voiceT.addTickable(note));
        new Vex.Flow.Formatter().joinVoices([voiceT]).format([voiceT], staveT.getWidth() - 20);
        voiceT.draw(contextT, staveT);
        
        // Bass-System (untere Zeile)
        const notationBass = document.createElement("div");
        notationBass.id = "notationBass";
        container.appendChild(notationBass);
        const rendererB = new Vex.Flow.Renderer(notationBass, Vex.Flow.Renderer.Backends.SVG);
        rendererB.resize(width, height);
        const svgB = notationBass.querySelector("svg");
        svgB && (svgB.setAttribute("width", baseWidth), svgB.setAttribute("height", 300));
        const contextB = rendererB.getContext();
        const staveB = new Vex.Flow.Stave(10, 40, baseWidth - 20);
        currentSeriesBass.length && staveB.addClef("bass").setContext(contextB).draw();
        const staveNotesB = currentSeriesBass.map(item => new Vex.Flow.StaveNote({
          clef: "bass",
          keys: [item.note + "/" + item.octave],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color }));
        const voiceB = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotesB.forEach(note => voiceB.addTickable(note));
        new Vex.Flow.Formatter().joinVoices([voiceB]).format([voiceB], staveB.getWidth() - 20);
        voiceB.draw(contextB, staveB);
      }
    };
    
    // Verarbeitung der MIDI-Nachrichten
    const handleMIDIMessage = (status, data1, data2) => {
      if (sessionPaused) return;
      if ((status & 0xf0) === 0x90 && data2 > 0) {
        let currentTime = Date.now();
        let responseTime = currentTime - lastNoteTimestamp;
        responseTimes.push(responseTime);
        lastNoteTimestamp = currentTime;
        
        const midiInfo = midiNoteToName(data1);
        const noteName = midiInfo.note + midiInfo.octave;
        const noteDisplay = document.getElementById("noteNameDisplay");
        if (noteDisplay) noteDisplay.textContent = noteName;
        if (soundEnabled) {
          synth.triggerAttackRelease(noteName, "8n");
        }
        totalAttempts++;
        
        if (selectedMode !== "both") {
          // Einhandmodus – bisherige Logik:
          const correct = isNoteCorrect(midiInfo);
          if (correct) {
            currentSeriesSingle[seriesCounter].color = "green";
            correctAnswers++;
            correctNoteCount++;
            removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
            if (correctNoteCount >= nextMotivationThreshold) {
              showMotivationMessage();
              nextMotivationThreshold = correctNoteCount + getRandomThreshold();
            }
          } else {
            currentSeriesSingle[seriesCounter].color = "red";
            errorNotes.push(currentSeriesSingle[seriesCounter]);
            if (!unlimitedLives) {
              hearts--;
              updateHeartsDisplay();
              if (hearts <= 0) {
                endGame();
                return;
              }
            }
          }
          seriesCounter++;
          if (seriesCounter >= seriesLength) {
            queueRedraw();
            setTimeout(generateSeries, 300);
          } else {
            queueRedraw();
          }
          updateTimer();
        } else {
          // Zweihandmodus: Notenpaar (Treble und Bass) verarbeiten
          if (pairInputs.firstNoteTime === 0) {
            // Erster Ton des Paares
            pairInputs.firstNoteTime = currentTime;
          }
          let timeDiff = currentTime - pairInputs.firstNoteTime;
          let matchedTreble = isNoteCorrectForClef(midiInfo, currentSeriesTreble[seriesCounter]);
          let matchedBass = isNoteCorrectForClef(midiInfo, currentSeriesBass[seriesCounter]);
          
          if (timeDiff < 200) {
            // Simultanes Spielen: Akzeptiere beide unabhängig von der Reihenfolge
            if (!pairInputs.treble && matchedTreble) {
              pairInputs.treble = true;
              currentSeriesTreble[seriesCounter].color = "green";
              correctAnswers++;
            } else if (!pairInputs.bass && matchedBass) {
              pairInputs.bass = true;
              currentSeriesBass[seriesCounter].color = "green";
              correctAnswers++;
            } else {
              // Falls die Note zu keinem noch fehlenden Teil passt, markiere Fehler
              if (!pairInputs.treble) {
                currentSeriesTreble[seriesCounter].color = "red";
                errorNotes.push(currentSeriesTreble[seriesCounter]);
              }
              if (!pairInputs.bass) {
                currentSeriesBass[seriesCounter].color = "red";
                errorNotes.push(currentSeriesBass[seriesCounter]);
              }
            }
          } else {
            // Sequentielles Spielen: Erwartet wird, dass zuerst die Treble-Note und dann die Bass-Note gespielt wird.
            if (!pairInputs.treble) {
              currentSeriesTreble[seriesCounter].color = "red";
              errorNotes.push(currentSeriesTreble[seriesCounter]);
            } else if (!pairInputs.bass) {
              if (matchedBass) {
                pairInputs.bass = true;
                currentSeriesBass[seriesCounter].color = "green";
                correctAnswers++;
              } else {
                currentSeriesBass[seriesCounter].color = "red";
                errorNotes.push(currentSeriesBass[seriesCounter]);
              }
            }
          }
          
          // Wenn beide Noten des Paares erkannt wurden, fahre fort:
          if (pairInputs.treble && pairInputs.bass) {
            seriesCounter++;
            pairInputs = { treble: false, bass: false, firstNoteTime: 0 };
            correctNoteCount++;
            if (correctNoteCount >= nextMotivationThreshold) {
              showMotivationMessage();
              nextMotivationThreshold = correctNoteCount + getRandomThreshold();
            }
            sessionCounter--;
            if (sessionCounter <= 0) {
              sessionCounter = 0;
              startPauseCountdown();
              updateTimer();
              return;
            }
            queueRedraw();
            if (seriesCounter >= seriesLength) {
              setTimeout(generateSeries, 300);
            }
          }
          updateTimer();
        }
      }
    };
    
    const resetGame = () => {
      hearts = 4;
      gameOver = false;
      seriesCounter = 0;
      totalAttempts = 0;
      correctAnswers = 0;
      correctNoteCount = 0;
      nextMotivationThreshold = getRandomThreshold();
      sessionCounter = 1000;
      sessionPaused = false;
      confettiShown = false;
      errorNotes = [];
      document.getElementById("gameOverOverlay").style.display = "none";
      scoreRecorded = false;
      generateSeries();
      updateHeartsDisplay();
    };
  </script>
</head>
<body>
  <!-- Welcome Overlay -->
  <div id="welcomeOverlay">
    <div id="welcomeMessage">Hallo, schön dich zu sehen!<br>V23:45</div>
  </div>
  <!-- Game Over / Session-Pause Overlay -->
  <div id="gameOverOverlay"></div>
  <!-- Scoreboard Overlay -->
  <div id="scoreboardOverlay" class="hidden"></div>
  <!-- Motivationsfenster -->
  <div id="motivationOverlay"></div>
  <!-- Timer Container -->
  <div id="timerContainer"></div>
  <!-- Hauptinhalt -->
  <div id="mainContent" style="opacity: 0;">
    <!-- Notation (Einhandmodus) -->
    <div id="notation"></div>
    <!-- Container für 2-Handmodus -->
    <div id="notationContainer"></div>
    <!-- Lagewechsel-Button & Herzen -->
    <div id="buttonContainer" style="z-index:50;">
      <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
      <div id="heartsContainer" style="margin-left:10px;"></div>
    </div>
    <!-- Notenname-Anzeige -->
    <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:1.5em;"></div>
  </div>
  <!-- Einstellungen-Menü -->
  <div id="settingsPanel"></div>
  <!-- Audio-Element für den Gong -->
  <audio id="gongSound" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg"></audio>
</body>
</html>
