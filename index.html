<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Untitled</title>
  <link rel="stylesheet" href="./style.css">
<style>
body {
  font-family: sans-serif;
  text-align: center;
}

#notation {
  width: 820px;       /* feste Breite, passend zur maximalen Notenreihe */
  margin: 0 auto;     /* zentriert den Container horizontal */
  text-align: center; /* falls SVG-Inhalte inline-block sind */
}

.active-mode, .active-level {
  opacity: 1;
}

.inactive-mode, .inactive-level {
  opacity: 0.5;
}

.active-range {
  font-weight: bold;
  color: #ef7d00;
}
  
</style>
</head>
<body>
<!-- partial:index.partial.html -->
<!-- VexFlow zur Darstellung der Notation einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
</head>
<body>
  <!-- MIDI-Statusanzeige oben links -->
<div id="midiStatus" style="position: absolute; top: 10px; left: 10px; font-size: 1em;"></div>
  <h1>C-Lage</h1>
<!-- Handmodus-Auswahl -->
<div id="modeSelector">
  <span id="mode-left" style="cursor: pointer; font-size: 2em; margin: 5px;">‚úã</span>
  <span id="mode-right" style="cursor: pointer; font-size: 2em; margin: 5px; display:inline-block; transform: scaleX(-1);">‚úã</span>
  <span id="mode-both" style="cursor: pointer; font-size: 2em; margin: 5px;">üôå</span>
</div>

<!-- Level-Auswahl -->
<div id="levelSelector">
  <span id="level-1" style="cursor: pointer; font-size: 2em; margin: 5px;">1Ô∏è‚É£</span>
  <span id="level-2" style="cursor: pointer; font-size: 2em; margin: 5px;">2Ô∏è‚É£</span>
  <span id="level-3" style="cursor: pointer; font-size: 2em; margin: 5px;">3Ô∏è‚É£</span>
</div>
  

<div id="notation"></div>
<div id="score">Score: 0%</div>
<div id="responseTime">üèéÔ∏è -- ms</div>
  <script>
 document.addEventListener("DOMContentLoaded", function() {
  // Array mit den nat√ºrlichen Noten der C‚ÄëLage
  const notes = ["c", "d", "e", "f", "g"];

  // Aktuelle Serie von Noten: jedes Element { note, octave, clef, color }
  let currentSeries = [];
  // Index der aktuell erwarteten Note in der Serie 
  let seriesCounter = 0;
  // Globaler Zeitstempel, ab dem die Antwortzeit gemessen wird
  let noteStartTime = 0;

  // Standard-Handmodus:
  // "right": rechte Hand (Violinschl√ºssel, Oktave 4)
  // "left": linke Hand (Bassschl√ºssel, Oktave 3)
  // "both": f√ºr jede Note zuf√§llig zwischen beiden
  let selectedMode = "right";

  // Standard-Level:
  // Level 1: 1 Note, Level 2: 5 Noten, Level 3: 10 Noten
  let level = 1;
  let seriesLength = 1;

  // --- Handmodus-Auswahl ---
  const modeLeft = document.getElementById("mode-left");
  const modeRight = document.getElementById("mode-right");
  const modeBoth = document.getElementById("mode-both");

  modeLeft.addEventListener("click", function() {
    selectedMode = "left";
    setActiveModeIcon("left");
    generateSeries();
  });
  modeRight.addEventListener("click", function() {
    selectedMode = "right";
    setActiveModeIcon("right");
    generateSeries();
  });
  modeBoth.addEventListener("click", function() {
    selectedMode = "both";
    setActiveModeIcon("both");
    generateSeries();
  });

  function setActiveModeIcon(mode) {
    modeLeft.classList.add("inactive-mode");
    modeRight.classList.add("inactive-mode");
    modeBoth.classList.add("inactive-mode");
    modeLeft.classList.remove("active-mode");
    modeRight.classList.remove("active-mode");
    modeBoth.classList.remove("active-mode");
    if (mode === "left") {
      modeLeft.classList.remove("inactive-mode");
      modeLeft.classList.add("active-mode");
    } else if (mode === "right") {
      modeRight.classList.remove("inactive-mode");
      modeRight.classList.add("active-mode");
    } else if (mode === "both") {
      modeBoth.classList.remove("inactive-mode");
      modeBoth.classList.add("active-mode");
    }
  }

  // --- Level-Auswahl ---
  const level1 = document.getElementById("level-1");
  const level2 = document.getElementById("level-2");
  const level3 = document.getElementById("level-3");

  level1.addEventListener("click", function() {
    level = 1;
    seriesLength = 1;
    seriesCounter = 0;
    setActiveLevel("1");
    generateSeries();
  });
  level2.addEventListener("click", function() {
    level = 2;
    seriesLength = 5;
    seriesCounter = 0;
    setActiveLevel("2");
    generateSeries();
  });
  level3.addEventListener("click", function() {
    level = 3;
    seriesLength = 10;
    seriesCounter = 0;
    setActiveLevel("3");
    generateSeries();
  });

  function setActiveLevel(lvl) {
    level1.classList.add("inactive-level");
    level2.classList.add("inactive-level");
    level3.classList.add("inactive-level");
    level1.classList.remove("active-level");
    level2.classList.remove("active-level");
    level3.classList.remove("active-level");
    if (lvl === "1") {
      level1.classList.remove("inactive-level");
      level1.classList.add("active-level");
    } else if (lvl === "2") {
      level2.classList.remove("inactive-level");
      level2.classList.add("active-level");
    } else if (lvl === "3") {
      level3.classList.remove("inactive-level");
      level3.classList.add("active-level");
    }
  }

  // --- VexFlow und Score ---
  const VF = Vex.Flow;
  const notationDiv = document.getElementById("notation");
  const scoreDiv = document.getElementById("score");
  const responseDiv = document.getElementById("responseTime");

  // Zeichnet die aktuelle Serie von Noten nebeneinander.
  // Die Breite wird dynamisch an die Anzahl der Noten angepasst.
  function drawSeries() {
    notationDiv.innerHTML = "";
    const usedWidth = 80 * seriesLength + 20; // Dynamische Breite: 80px pro Note + 20px Padding
    const renderer = new VF.Renderer(notationDiv, VF.Renderer.Backends.SVG);
    renderer.resize(usedWidth, 200);
    const context = renderer.getContext();

    // Erstelle einen Stave mit der dynamischen Breite, beginnend bei x=10
    const stave = new VF.Stave(10, 40, usedWidth - 20);
    stave.addClef(currentSeries[0].clef).setContext(context).draw();

    // Erstelle StaveNotes f√ºr alle Noten der aktuellen Serie
    const staveNotes = currentSeries.map(function(item) {
      return new VF.StaveNote({
        clef: item.clef,
        keys: [item.note + "/" + item.octave],
        duration: "q"
      }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
    });

    const voice = new VF.Voice({ num_beats: seriesLength, beat_value: 4 });
    staveNotes.forEach(note => voice.addTickable(note));
    new VF.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
    voice.draw(context, stave);
  }

  // --- Score und Antwortzeit ---
  let totalAttempts = 0;
  let correctAnswers = 0;
  function updateScore() {
    let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
    scoreDiv.textContent = "Score: " + percent + "%";
  }

  // --- Serien-Generierung ---
  // Level 1 und 2: Jede Note zuf√§llig gew√§hlt
  // Level 3: Eine Serie von 10 Noten, wobei die √úberg√§nge Intervallbeziehungen (Sekunde, Terz, Quarte, Quinte) nutzen
  function generateSeries() {
    currentSeries = [];
    seriesCounter = 0;
    if (level < 3) {
      for (let i = 0; i < seriesLength; i++) {
        let note = notes[Math.floor(Math.random() * notes.length)];
        let clef, octave;
        if (selectedMode === "right") {
          clef = "treble";
          octave = 4;
        } else if (selectedMode === "left") {
          clef = "bass";
          octave = 3;
        } else if (selectedMode === "both") {
          if (Math.random() < 0.5) {
            clef = "treble";
            octave = 4;
          } else {
            clef = "bass";
            octave = 3;
          }
        }
        currentSeries.push({ note: note, octave: octave, clef: clef, color: "black" });
      }
    } else {
      // Level 3: Erzeuge eine Serie mit Intervallbeziehungen
      let currentIndex = Math.floor(Math.random() * notes.length);
      let clef, octave;
      if (selectedMode === "right") {
        clef = "treble";
        octave = 4;
      } else if (selectedMode === "left") {
        clef = "bass";
        octave = 3;
      } else if (selectedMode === "both") {
        if (Math.random() < 0.5) {
          clef = "treble";
          octave = 4;
        } else {
          clef = "bass";
          octave = 3;
        }
      }
      currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
      // Erzeuge die restlichen 9 Noten
      for (let i = 1; i < seriesLength; i++) {
        const intervals = [1, 2, 3, 4]; // 1: Sekunde, 2: Terz, 3: Quarte, 4: Quinte
        let interval = intervals[Math.floor(Math.random() * intervals.length)];
        let direction = Math.random() < 0.5 ? 1 : -1;
        if (currentIndex + direction * interval < 0 || currentIndex + direction * interval >= notes.length) {
          direction *= -1;
        }
        currentIndex = currentIndex + direction * interval;
        if (selectedMode === "right") {
          clef = "treble";
          octave = 4;
        } else if (selectedMode === "left") {
          clef = "bass";
          octave = 3;
        } else if (selectedMode === "both") {
          if (Math.random() < 0.5) {
            clef = "treble";
            octave = 4;
          } else {
            clef = "bass";
            octave = 3;
          }
        }
        currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
      }
    }
    drawSeries();
    noteStartTime = Date.now(); // Startzeit setzen
  }

  // --- MIDI-Integration ---
  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
  } else {
    alert("Dein Browser unterst√ºtzt das Web MIDI API nicht.");
  }

  function onMIDISuccess(midiAccess) {
    console.log("MIDI ist bereit!");
    const inputs = midiAccess.inputs.values();
    for (let input of inputs) {
      input.onmidimessage = handleMIDIMessage;
    }
    generateSeries();
  }

  function onMIDIFailure() {
    alert("Kein Zugriff auf MIDI-Ger√§te m√∂glich.");
  }

  function midiNoteToName(noteNumber) {
    const noteNames = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
    let octave = Math.floor(noteNumber / 12) - 1;
    let noteName = noteNames[noteNumber % 12];
    return { noteName, octave };
  }

  // --- Verarbeitung der MIDI-Nachrichten ---
  // Vergleicht die aktuell erwartete Note in currentSeries[seriesCounter] mit der gespielten Note.
  function handleMIDIMessage(event) {
    console.log("MIDI-Nachricht:", event.data);
    const [status, data1, data2] = event.data;
    if (status >= 144 && status < 160 && data2 > 0) {
      const midiInfo = midiNoteToName(data1);
      console.log("Empfangene Note:", midiInfo.noteName, midiInfo.octave);
      totalAttempts++;
      const expected = currentSeries[seriesCounter];
      const responseTime = Date.now() - noteStartTime;
      responseDiv.textContent = "Response Time: " + responseTime + " ms";
      
      if (midiInfo.noteName === expected.note && midiInfo.octave === expected.octave) {
        correctAnswers++;
        expected.color = "green";
      } else {
        expected.color = "red";
      }
      updateScore();
      drawSeries();
      seriesCounter++;
      noteStartTime = Date.now();
      setTimeout(function() {
        if (seriesCounter >= seriesLength) {
          generateSeries();
        }
      }, 500);
    }
  }

  function updateScore() {
    let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
    scoreDiv.textContent = "Score: " + percent + "%";
  }
});
  </script>
  <script>
 document.addEventListener("DOMContentLoaded", function() {
  const midiStatusDiv = document.getElementById("midiStatus");

  // Diese Funktion setzt alle interaktiven Elemente (IDs, die du hier auflistest)
  // auf "disabled" (pointer-events: none und reduzierte Opazit√§t)
  function disableInteractiveElements(disable) {
    const interactiveIds = ["modeSelector", "levelSelector", "rangeHeader", "btn-dlage"];
    interactiveIds.forEach(function(id) {
      const elem = document.getElementById(id);
      if (elem) {
        if (disable) {
          elem.style.pointerEvents = "none";
          elem.style.opacity = "0.5";
        } else {
          elem.style.pointerEvents = "auto";
          elem.style.opacity = "1";
        }
      }
    });
  }

  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then(function(midiAccess) {
      function updateMIDIStatus() {
        let hasInput = false;
        // √úberpr√ºfe alle MIDI-Eing√§nge
        for (let input of midiAccess.inputs.values()) {
          console.log("MIDI Input:", input.name, input.state);
          if (input.state === "connected") {
            hasInput = true;
            break;
          }
        }
        if (hasInput) {
          midiStatusDiv.textContent = "üîå";
          disableInteractiveElements(false);
        } else {
          midiStatusDiv.textContent = "‚õî Keine MIDI Verbindung";
          disableInteractiveElements(true);
        }
      }
      // Status sofort pr√ºfen und dann jede Sekunde
      updateMIDIStatus();
      setInterval(updateMIDIStatus, 1000);
    }, function() {
      midiStatusDiv.textContent = "‚õî";
      disableInteractiveElements(true);
    });
  } else {
    midiStatusDiv.textContent = "‚õî";
    disableInteractiveElements(true);
  }
});
  </script>   
</body>
<!-- partial -->
  <script src='https://unpkg.com/vexflow/releases/vexflow-min.js'></script>
</body>
</html>
