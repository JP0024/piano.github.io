<head>
  <meta charset="UTF-8">
  <title>Notentraining</title>
  <link rel="stylesheet" href="./style.css">
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }

    #notation {
      width: 820px; 
      transform: scale(2); /* Vergr√∂√üert den Container um das 1,5-fache */
      /* feste Breite, passend zur maximalen Notenreihe */
      margin: 0 auto;     /* zentriert den Container horizontal */
      text-align: center; /* falls SVG-Inhalte inline-block sind */
    }

    .active-mode, .active-level, .active-range {
      opacity: 1;
      font-weight: bold;
      color: black;
    }

    .inactive-mode, .inactive-level, .inactive-range {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <!-- MIDI-Statusanzeige oben links -->
  <div id="midiStatus" style="position: absolute; top: 10px; left: 10px; font-size: 1em;"></div>

  <!-- √úberschrift; Text passt sich an die aktuelle Lage an -->
  <h1>Notentraining</h1>

  <!-- Range-Auswahl: C, D, F, G und Mittlere C -->
  <div id="rangeSelector">
    <span id="range-c" style="cursor: pointer; font-size: 1.5em; margin: 5px;">C-Lage</span>
    <span id="range-d" style="cursor: pointer; font-size: 1.5em; margin: 5px;">D-Lage</span>
    <span id="range-f" style="cursor: pointer; font-size: 1.5em; margin: 5px;">F-Lage</span>
    <span id="range-g" style="cursor: pointer; font-size: 1.5em; margin: 5px;">G-Lage</span>
    <span id="range-mc" style="cursor: pointer; font-size: 1.5em; margin: 5px;">Mittlere C</span>
  </div>
<br>
  <!-- Handmodus-Auswahl -->
  <div id="modeSelector">
    <span id="mode-left" style="cursor: pointer; font-size: 2em; margin: 5px;">‚úã</span>
    <span id="mode-right" style="cursor: pointer; font-size: 2em; margin: 5px; display:inline-block; transform: scaleX(-1);">‚úã</span>
    <span id="mode-both" style="cursor: pointer; font-size: 2em; margin: 5px;">üôå</span>
  </div>
<br>
  <!-- Level-Auswahl inklusive Zufallsauswahl der Lage -->
  <div id="levelSelector">
    <span id="level-1" style="cursor: pointer; font-size: 2em; margin: 5px;">1Ô∏è‚É£</span>
    <span id="level-2" style="cursor: pointer; font-size: 2em; margin: 5px;">2Ô∏è‚É£</span>
    <span id="level-3" style="cursor: pointer; font-size: 2em; margin: 5px;">3Ô∏è‚É£</span>
    <span id="level-random" style="cursor: pointer; font-size: 2em; margin: 5px;">üéâ</span>
  </div>

  <div id="notation"></div>
  <div id="score">Score: 0%</div>
  <div id="responseTime">üèéÔ∏è -- ms</div>

  <!-- VexFlow einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {

      // Globale Zust√§nde
      let currentRange = "C"; // Standard: C-Lage
      let selectedMode = "right"; // "right" (Violinschl√ºssel, Oktave 4), "left" (Bassschl√ºssel, Oktave 3), "both"
      let level = 1; // Level 1: 1 Note, Level 2: 5 Noten, Level 3: 10 Noten
      let seriesLength = 1;
      let currentSeries = [];
      let seriesCounter = 0;
      let noteStartTime = 0;
      let totalAttempts = 0;
      let correctAnswers = 0;

      // Notenarrays f√ºr die jeweiligen Lagen
      // F√ºr F-Lage verwenden wir z.‚ÄØB. "bb" f√ºr B‚Äëflat.
      const rangeNotes = {
        "C": ["c", "d", "e", "f", "g"],
        "D": ["d", "e", "f#", "g", "a"],
        "F": ["f", "g", "a", "bb", "c"],
        "G": ["g", "a", "b", "c", "d"],
        "MC": ["c", "d", "e", "f", "g"] // Mittlere C-Lage
      };

      // --- Range-Auswahl ---
      const rangeC = document.getElementById("range-c");
      const rangeD = document.getElementById("range-d");
      const rangeF = document.getElementById("range-f");
      const rangeG = document.getElementById("range-g");
      const rangeMC = document.getElementById("range-mc");

      rangeC.addEventListener("click", function() {
        currentRange = "C";
        document.querySelector("h1").textContent = "C-Lage";
        setActiveRange("range-c");
        generateSeries();
      });
      rangeD.addEventListener("click", function() {
        currentRange = "D";
        document.querySelector("h1").textContent = "D-Lage";
        setActiveRange("range-d");
        generateSeries();
      });
      rangeF.addEventListener("click", function() {
        currentRange = "F";
        document.querySelector("h1").textContent = "F-Lage";
        setActiveRange("range-f");
        generateSeries();
      });
      rangeG.addEventListener("click", function() {
        currentRange = "G";
        document.querySelector("h1").textContent = "G-Lage";
        setActiveRange("range-g");
        generateSeries();
      });
      rangeMC.addEventListener("click", function() {
        currentRange = "MC";
        document.querySelector("h1").textContent = "Mittlere C-Lage";
        setActiveRange("range-mc");
        generateSeries();
      });

      function setActiveRange(activeId) {
        // Alle Range-Buttons auf inaktiv setzen
        [rangeC, rangeD, rangeF, rangeG, rangeMC].forEach(function(elem) {
          elem.classList.remove("active-range");
          elem.classList.add("inactive-range");
        });
        // Den ausgew√§hlten Button aktivieren
        document.getElementById(activeId).classList.remove("inactive-range");
        document.getElementById(activeId).classList.add("active-range");
      }
      // Standardm√§√üig aktivieren wir C-Lage
      setActiveRange("range-c");

      // --- Handmodus-Auswahl ---
      const modeLeft = document.getElementById("mode-left");
      const modeRight = document.getElementById("mode-right");
      const modeBoth = document.getElementById("mode-both");

      modeLeft.addEventListener("click", function() {
        selectedMode = "left";
        setActiveModeIcon("left");
        generateSeries();
      });
      modeRight.addEventListener("click", function() {
        selectedMode = "right";
        setActiveModeIcon("right");
        generateSeries();
      });
      modeBoth.addEventListener("click", function() {
        selectedMode = "both";
        setActiveModeIcon("both");
        generateSeries();
      });

      function setActiveModeIcon(mode) {
        modeLeft.classList.add("inactive-mode");
        modeRight.classList.add("inactive-mode");
        modeBoth.classList.add("inactive-mode");
        modeLeft.classList.remove("active-mode");
        modeRight.classList.remove("active-mode");
        modeBoth.classList.remove("active-mode");
        if (mode === "left") {
          modeLeft.classList.remove("inactive-mode");
          modeLeft.classList.add("active-mode");
        } else if (mode === "right") {
          modeRight.classList.remove("inactive-mode");
          modeRight.classList.add("active-mode");
        } else if (mode === "both") {
          modeBoth.classList.remove("inactive-mode");
          modeBoth.classList.add("active-mode");
        }
      }

      // --- Level-Auswahl ---
      const level1 = document.getElementById("level-1");
      const level2 = document.getElementById("level-2");
      const level3 = document.getElementById("level-3");
      const levelRandom = document.getElementById("level-random");

      level1.addEventListener("click", function() {
        level = 1;
        seriesLength = 1;
        seriesCounter = 0;
        setActiveLevel("1");
        generateSeries();
      });
      level2.addEventListener("click", function() {
        level = 2;
        seriesLength = 5;
        seriesCounter = 0;
        setActiveLevel("2");
        generateSeries();
      });
      level3.addEventListener("click", function() {
        level = 3;
        seriesLength = 10;
        seriesCounter = 0;
        setActiveLevel("3");
        generateSeries();
      });
      // Zufalls-Lagenwahl √ºber den üéâ-Button
      levelRandom.addEventListener("click", function() {
        const ranges = ["C", "D", "F", "G", "MC"];
        const randomRange = ranges[Math.floor(Math.random() * ranges.length)];
        currentRange = randomRange;
        let headerText = "";
        let activeId = "";
        switch(randomRange) {
          case "C":
            headerText = "C-Lage";
            activeId = "range-c";
            break;
          case "D":
            headerText = "D-Lage";
            activeId = "range-d";
            break;
          case "F":
            headerText = "F-Lage";
            activeId = "range-f";
            break;
          case "G":
            headerText = "G-Lage";
            activeId = "range-g";
            break;
          case "MC":
            headerText = "Mittlere C-Lage";
            activeId = "range-mc";
            break;
        }
        document.querySelector("h1").textContent = headerText;
        setActiveRange(activeId);
        generateSeries();
      });

      function setActiveLevel(lvl) {
        level1.classList.add("inactive-level");
        level2.classList.add("inactive-level");
        level3.classList.add("inactive-level");
        level1.classList.remove("active-level");
        level2.classList.remove("active-level");
        level3.classList.remove("active-level");
        if (lvl === "1") {
          level1.classList.remove("inactive-level");
          level1.classList.add("active-level");
        } else if (lvl === "2") {
          level2.classList.remove("inactive-level");
          level2.classList.add("active-level");
        } else if (lvl === "3") {
          level3.classList.remove("inactive-level");
          level3.classList.add("active-level");
        }
      }

      // --- VexFlow und Anzeige ---
      const VF = Vex.Flow;
      const notationDiv = document.getElementById("notation");
      const scoreDiv = document.getElementById("score");
      const responseDiv = document.getElementById("responseTime");

      // Zeichnet die aktuelle Serie von Noten
      function drawSeries() {
        notationDiv.innerHTML = "";
        const usedWidth = 80 * seriesLength + 20; // Dynamische Breite: 80px pro Note + 20px Padding
        const renderer = new VF.Renderer(notationDiv, VF.Renderer.Backends.SVG);
        renderer.resize(usedWidth, 200);
        const context = renderer.getContext();

        // Erstelle einen Stave mit dynamischer Breite
        const stave = new VF.Stave(10, 40, usedWidth - 20);
        stave.addClef(currentSeries[0].clef).setContext(context).draw();

        // Erstelle Notenobjekte
        const staveNotes = currentSeries.map(function(item) {
          return new VF.StaveNote({
            clef: item.clef,
            keys: [item.note + "/" + item.octave],
            duration: "q"
          }).setStyle({ fillStyle: item.color, strokeStyle: item.color });
        });

        const voice = new VF.Voice({ num_beats: seriesLength, beat_value: 4 });
        staveNotes.forEach(note => voice.addTickable(note));
        new VF.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
        voice.draw(context, stave);
      }

      // --- Score und Antwortzeit ---
      function updateScore() {
        let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
        scoreDiv.textContent = "Score: " + percent + "%";
      }

      // --- Serien-Generierung ---
      function generateSeries() {
        currentSeries = [];
        seriesCounter = 0;
        // W√§hle das Notenarray anhand der aktuellen Lage aus
        const notes = rangeNotes[currentRange];

        if (level < 3) {
          for (let i = 0; i < seriesLength; i++) {
            let note = notes[Math.floor(Math.random() * notes.length)];
            let clef, octave;
            if (selectedMode === "right") {
              clef = "treble";
              octave = 4;
            } else if (selectedMode === "left") {
              clef = "bass";
              octave = 3;
            } else if (selectedMode === "both") {
              if (Math.random() < 0.5) {
                clef = "treble";
                octave = 4;
              } else {
                clef = "bass";
                octave = 3;
              }
            }
            currentSeries.push({ note: note, octave: octave, clef: clef, color: "black" });
          }
        } else {
          // Level 3: Serie mit Intervallbeziehungen
          let currentIndex = Math.floor(Math.random() * notes.length);
          let clef, octave;
          if (selectedMode === "right") {
            clef = "treble";
            octave = 4;
          } else if (selectedMode === "left") {
            clef = "bass";
            octave = 3;
          } else if (selectedMode === "both") {
            if (Math.random() < 0.5) {
              clef = "treble";
              octave = 4;
            } else {
              clef = "bass";
              octave = 3;
            }
          }
          currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
          for (let i = 1; i < seriesLength; i++) {
            const intervals = [1, 2, 3, 4]; // Sekunde, Terz, Quarte, Quinte
            let interval = intervals[Math.floor(Math.random() * intervals.length)];
            let direction = Math.random() < 0.5 ? 1 : -1;
            if (currentIndex + direction * interval < 0 || currentIndex + direction * interval >= notes.length) {
              direction *= -1;
            }
            currentIndex = currentIndex + direction * interval;
            if (selectedMode === "right") {
              clef = "treble";
              octave = 4;
            } else if (selectedMode === "left") {
              clef = "bass";
              octave = 3;
            } else if (selectedMode === "both") {
              if (Math.random() < 0.5) {
                clef = "treble";
                octave = 4;
              } else {
                clef = "bass";
                octave = 3;
              }
            }
            currentSeries.push({ note: notes[currentIndex], octave: octave, clef: clef, color: "black" });
          }
        }
        drawSeries();
        noteStartTime = Date.now(); // Startzeit setzen
      }

      // --- MIDI-Integration ---
      if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
      } else {
        alert("Dein Browser unterst√ºtzt das Web MIDI API nicht.");
      }

      function onMIDISuccess(midiAccess) {
        console.log("MIDI ist bereit!");
        const inputs = midiAccess.inputs.values();
        for (let input of inputs) {
          input.onmidimessage = handleMIDIMessage;
        }
        generateSeries();
      }

      function onMIDIFailure() {
        alert("Kein Zugriff auf MIDI-Ger√§te m√∂glich.");
      }

      function midiNoteToName(noteNumber) {
        const noteNames = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
        let octave = Math.floor(noteNumber / 12) - 1;
        let noteName = noteNames[noteNumber % 12];
        return { noteName, octave };
      }

      // --- Verarbeitung der MIDI-Nachrichten ---
      function handleMIDIMessage(event) {
        console.log("MIDI-Nachricht:", event.data);
        const [status, data1, data2] = event.data;
        if (status >= 144 && status < 160 && data2 > 0) {
          const midiInfo = midiNoteToName(data1);
          console.log("Empfangene Note:", midiInfo.noteName, midiInfo.octave);
          totalAttempts++;
          const expected = currentSeries[seriesCounter];
          const responseTime = Date.now() - noteStartTime;
          responseDiv.textContent = "Response Time: " + responseTime + " ms";

          if (midiInfo.noteName === expected.note && midiInfo.octave === expected.octave) {
            correctAnswers++;
            expected.color = "green";
          } else {
            expected.color = "red";
          }
          updateScore();
          drawSeries();
          seriesCounter++;
          noteStartTime = Date.now();
          setTimeout(function() {
            if (seriesCounter >= seriesLength) {
              generateSeries();
            }
          }, 500);
        }
      }

      function updateScore() {
        let percent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
        scoreDiv.textContent = "Score: " + percent + "%";
      }
    });
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const midiStatusDiv = document.getElementById("midiStatus");

      function disableInteractiveElements(disable) {
        const interactiveIds = ["modeSelector", "levelSelector", "rangeSelector"];
        interactiveIds.forEach(function(id) {
          const elem = document.getElementById(id);
          if (elem) {
            if (disable) {
              elem.style.pointerEvents = "none";
              elem.style.opacity = "0.5";
            } else {
              elem.style.pointerEvents = "auto";
              elem.style.opacity = "1";
            }
          }
        });
      }

      if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(function(midiAccess) {
          function updateMIDIStatus() {
            let hasInput = false;
            for (let input of midiAccess.inputs.values()) {
              console.log("MIDI Input:", input.name, input.state);
              if (input.state === "connected") {
                hasInput = true;
                break;
              }
            }
            if (hasInput) {
              midiStatusDiv.textContent = "üîå";
              disableInteractiveElements(false);
            } else {
              midiStatusDiv.textContent = "‚õî Keine MIDI Verbindung";
              disableInteractiveElements(true);
            }
          }
          updateMIDIStatus();
          setInterval(updateMIDIStatus, 1000);
        }, function() {
          midiStatusDiv.textContent = "‚õî";
          disableInteractiveElements(true);
        });
      } else {
        midiStatusDiv.textContent = "‚õî";
        disableInteractiveElements(true);
      }
    });
  </script>   
  <script src='https://unpkg.com/vexflow/releases/vexflow-min.js'></script>
</body>
